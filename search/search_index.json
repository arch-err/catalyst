{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Catalyst","text":"<p>From quick idea capture to full project build -- powered by Claude Code.</p> <p>Catalyst is a personal web application that takes a raw idea from a quick phone capture through Claude-powered refinement to a fully built project, all within a single continuous Claude Code session. It runs on a local Kubernetes cluster behind a VPN, with Claude Code executing on a Vagrant dev-VM over SSH.</p>"},{"location":"#the-pipeline","title":"The Pipeline","text":"<p>Every idea flows through four stages:</p> <pre><code>Captured --&gt; Chatting --&gt; Building --&gt; Done\n</code></pre> <ol> <li>Capture -- Jot down a rough idea from your phone or browser. Give it a title and a short description.</li> <li>Chat -- Refine the idea with Claude in a read-only conversation. Claude can read files, search code, and explore the filesystem, but it cannot write anything yet. This is the brainstorming phase.</li> <li>Build -- When the idea is ready, switch to build mode. Claude gets full tool access and creates the entire project in a dedicated directory on the dev-VM.</li> <li>Done -- The project is built. Review the results, iterate, or start a new idea.</li> </ol>"},{"location":"#how-it-works","title":"How It Works","text":"<pre><code>Phone/Browser --&gt; k8s ingress (VPN) --&gt; Catalyst Pod --&gt; SSH --&gt; Dev-VM --&gt; Claude Code\n</code></pre> <p>Catalyst is a full-stack web application deployed as a single container on Kubernetes. When you send a message or trigger a build, the backend opens an SSH connection to a development VM where Claude Code is installed. It invokes <code>claude</code> with the appropriate arguments, streams the NDJSON output back over SSH, and relays it to your browser in real time over WebSocket.</p> <p>Because Claude Code runs on the dev-VM (not inside the container), it has access to a real development environment with all the tools, runtimes, and configurations that a human developer would use.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Mobile-first capture -- The UI is designed for quick idea entry on a phone. Open the app, type a title and description, and you are immediately in a session with Claude.</li> <li>Real-time streaming -- Claude's output streams to your browser as it is generated. You see text appear token by token, and you can watch tool calls (file reads, grep searches) happen live.</li> <li>Session persistence -- Each idea maintains a Claude Code session ID. When you return to an idea, the conversation picks up exactly where you left off.</li> <li>Two interaction modes -- Chat mode restricts Claude to read-only tools (<code>Read</code>, <code>Grep</code>, <code>Glob</code>) for safe exploration and refinement. Build mode unlocks all tools so Claude can create files, run commands, and build the project.</li> <li>Cancellation -- Long-running Claude processes can be cancelled from the UI. The backend sends <code>SIGINT</code> to the SSH channel, with a <code>SIGKILL</code> fallback after 5 seconds.</li> <li>Connection pooling -- SSH connections to the dev-VM are pooled and reused, with configurable limits and keepalive settings.</li> <li>Secure by default -- Authentication via a shared secret with timing-safe comparison, signed HTTP-only cookies, WebSocket auth on upgrade, and a Kubernetes NetworkPolicy that restricts traffic to the ingress controller and SSH egress only.</li> </ul>"},{"location":"#tech-stack","title":"Tech Stack","text":"Layer Technology Frontend React 18, TypeScript, Vite, Tailwind CSS 4, shadcn/ui, zustand, react-router-dom Backend Node.js, Express 4, TypeScript, SSH2, ws (WebSocket) Shared TypeScript types package (<code>@catalyst/shared</code>) Runtime Bun (package manager and runtime) Container Multi-stage Dockerfile on <code>oven/bun</code> Orchestration Kubernetes with Helm chart CI/CD GitHub Actions (typecheck, build, container image to GHCR, Helm chart to GHCR OCI) AI Claude Code CLI on a Vagrant dev-VM"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code>git clone &lt;repo-url&gt; catalyst\ncd catalyst\nbun install\nbun run dev\n</code></pre> <p>The frontend runs on <code>http://localhost:3000</code> and proxies API/WebSocket requests to the backend on port <code>3001</code>. See the Getting Started guide for full setup instructions.</p>"},{"location":"api/","title":"API Reference","text":"<p>Catalyst exposes a REST API for managing ideas and authentication, a WebSocket endpoint for real-time Claude interactions, and a health endpoint for monitoring.</p>"},{"location":"api/#base-url","title":"Base URL","text":"<ul> <li>Local development: <code>http://localhost:3001</code> (backend) or <code>http://localhost:3000</code> (through Vite proxy)</li> <li>Production: Your configured ingress hostname (e.g., <code>https://catalyst.yourdomain.com</code>)</li> </ul>"},{"location":"api/#authentication","title":"Authentication","text":"<p>All API endpoints except <code>/api/health</code>, <code>/api/login</code>, and <code>/api/auth/check</code> require authentication. Authentication is cookie-based:</p> <ol> <li>POST to <code>/api/login</code> with the shared secret.</li> <li>The server sets a signed <code>catalyst_session</code> cookie (HTTP-only, 30-day expiry).</li> <li>All subsequent requests include this cookie automatically.</li> </ol> <p>If a request to a protected endpoint lacks a valid session cookie, the server responds with:</p> <pre><code>{\n  \"ok\": false,\n  \"error\": \"Unauthorized\"\n}\n</code></pre> <p>HTTP status: <code>401</code></p>"},{"location":"api/#response-format","title":"Response Format","text":"<p>All REST API responses follow the <code>ApiResponse&lt;T&gt;</code> format:</p>"},{"location":"api/#success","title":"Success","text":"<pre><code>{\n  \"ok\": true,\n  \"data\": { ... }\n}\n</code></pre>"},{"location":"api/#error","title":"Error","text":"<pre><code>{\n  \"ok\": false,\n  \"error\": \"Description of what went wrong\"\n}\n</code></pre>"},{"location":"api/#endpoints-overview","title":"Endpoints Overview","text":""},{"location":"api/#rest-api","title":"REST API","text":"Method Path Auth Description <code>GET</code> <code>/api/health</code> No Health check with SSH status <code>POST</code> <code>/api/login</code> No Authenticate with shared secret <code>POST</code> <code>/api/logout</code> No Clear session <code>GET</code> <code>/api/auth/check</code> No Check authentication status <code>GET</code> <code>/api/ideas</code> Yes List all ideas <code>POST</code> <code>/api/ideas</code> Yes Create a new idea <code>GET</code> <code>/api/ideas/:idOrSlug</code> Yes Get a single idea <code>PATCH</code> <code>/api/ideas/:idOrSlug</code> Yes Update an idea <code>DELETE</code> <code>/api/ideas/:idOrSlug</code> Yes Delete an idea <p>See the REST API page for detailed request/response documentation.</p>"},{"location":"api/#websocket","title":"WebSocket","text":"URL Auth Description <code>/ws</code> Cookie (on upgrade) Real-time Claude Code interaction <p>See the WebSocket Protocol page for the full message schema.</p>"},{"location":"api/rest/","title":"REST API","text":"<p>Detailed documentation for all REST API endpoints.</p>"},{"location":"api/rest/#authentication-endpoints","title":"Authentication Endpoints","text":""},{"location":"api/rest/#post-apilogin","title":"POST <code>/api/login</code>","text":"<p>Authenticate with the shared secret. On success, sets a signed session cookie.</p> <p>Request:</p> <pre><code>{\n  \"secret\": \"your-catalyst-secret\"\n}\n</code></pre> <p>Headers:</p> <pre><code>Content-Type: application/json\n</code></pre> <p>Response (200 OK):</p> <pre><code>{\n  \"ok\": true\n}\n</code></pre> <p>Response (400 Bad Request):</p> <pre><code>{\n  \"ok\": false,\n  \"error\": \"Secret required\"\n}\n</code></pre> <p>Response (401 Unauthorized):</p> <pre><code>{\n  \"ok\": false,\n  \"error\": \"Invalid secret\"\n}\n</code></pre> <p>Cookie Set:</p> <pre><code>Set-Cookie: catalyst_session=s:&lt;token&gt;.&lt;signature&gt;;\n  Path=/;\n  HttpOnly;\n  SameSite=Strict;\n  Max-Age=2592000;\n  Secure  (production only)\n</code></pre> <p>The secret comparison uses <code>crypto.timingSafeEqual</code> to prevent timing attacks. The input and expected buffers must be the same length, so an incorrect-length secret will also return 401.</p>"},{"location":"api/rest/#post-apilogout","title":"POST <code>/api/logout</code>","text":"<p>Clear the session cookie and invalidate the token server-side.</p> <p>Request: No body required.</p> <p>Response (200 OK):</p> <pre><code>{\n  \"ok\": true\n}\n</code></pre> <p>The server removes the token from the in-memory set and clears the cookie.</p>"},{"location":"api/rest/#get-apiauthcheck","title":"GET <code>/api/auth/check</code>","text":"<p>Check whether the current session is authenticated. Used by the frontend on page load to verify an existing cookie.</p> <p>Response (200 OK):</p> <pre><code>{\n  \"ok\": true,\n  \"data\": {\n    \"authenticated\": true\n  }\n}\n</code></pre> <p>Or if not authenticated:</p> <pre><code>{\n  \"ok\": true,\n  \"data\": {\n    \"authenticated\": false\n  }\n}\n</code></pre> <p>Note: This endpoint always returns 200 OK. The <code>authenticated</code> field in the response data indicates the actual auth status.</p>"},{"location":"api/rest/#health-endpoint","title":"Health Endpoint","text":""},{"location":"api/rest/#get-apihealth","title":"GET <code>/api/health</code>","text":"<p>Returns the server's health status including SSH connectivity. This endpoint does not require authentication and is used by Kubernetes liveness and readiness probes.</p> <p>Response (200 OK):</p> <pre><code>{\n  \"status\": \"ok\",\n  \"ssh\": true,\n  \"uptime\": 42.5\n}\n</code></pre> Field Type Description <code>status</code> <code>\"ok\" \\| \"degraded\"</code> <code>\"ok\"</code> when SSH is healthy, <code>\"degraded\"</code> when SSH is unreachable <code>ssh</code> boolean Whether the backend can connect to the dev-VM <code>uptime</code> number Server uptime in seconds <p>If no SSH connections exist in the pool, the endpoint attempts a quick <code>echo ok</code> command to test connectivity.</p>"},{"location":"api/rest/#ideas-endpoints","title":"Ideas Endpoints","text":"<p>All ideas endpoints require authentication (the <code>catalyst_session</code> cookie).</p>"},{"location":"api/rest/#get-apiideas","title":"GET <code>/api/ideas</code>","text":"<p>List all ideas, sorted by <code>updatedAt</code> descending (most recently updated first).</p> <p>Response (200 OK):</p> <pre><code>{\n  \"ok\": true,\n  \"data\": [\n    {\n      \"id\": \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\",\n      \"slug\": \"my-cool-idea\",\n      \"title\": \"My Cool Idea\",\n      \"status\": \"chatting\",\n      \"sessionId\": \"sess_01J5XYZ...\",\n      \"createdAt\": \"2025-01-15T10:30:00.000Z\",\n      \"updatedAt\": \"2025-01-15T11:45:00.000Z\"\n    },\n    {\n      \"id\": \"b2c3d4e5-f6a7-8901-bcde-f12345678901\",\n      \"slug\": \"another-idea\",\n      \"title\": \"Another Idea\",\n      \"status\": \"captured\",\n      \"createdAt\": \"2025-01-14T09:00:00.000Z\",\n      \"updatedAt\": \"2025-01-14T09:00:00.000Z\"\n    }\n  ]\n}\n</code></pre> <p>Each item is an <code>IdeaMeta</code> object (without the <code>content</code> field). If no ideas exist yet, <code>data</code> is an empty array.</p>"},{"location":"api/rest/#post-apiideas","title":"POST <code>/api/ideas</code>","text":"<p>Create a new idea. This creates a directory on the dev-VM with <code>meta.json</code> and <code>idea.md</code> files.</p> <p>Request:</p> <pre><code>{\n  \"title\": \"My Cool Idea\",\n  \"content\": \"A web app that does X, Y, and Z. The main goal is to solve...\"\n}\n</code></pre> <p>Headers:</p> <pre><code>Content-Type: application/json\n</code></pre> <p>Response (201 Created):</p> <pre><code>{\n  \"ok\": true,\n  \"data\": {\n    \"id\": \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\",\n    \"slug\": \"my-cool-idea\",\n    \"title\": \"My Cool Idea\",\n    \"status\": \"captured\",\n    \"createdAt\": \"2025-01-15T10:30:00.000Z\",\n    \"updatedAt\": \"2025-01-15T10:30:00.000Z\"\n  }\n}\n</code></pre> <p>Response (400 Bad Request):</p> <pre><code>{\n  \"ok\": false,\n  \"error\": \"Title and content required\"\n}\n</code></pre> <p>The slug is generated from the title using the <code>slugify</code> library (lowercase, strict mode, special characters removed). The ID is a UUID v4.</p> <p>The backend calls <code>ensureBasePath()</code> before creating the idea, which runs <code>mkdir -p</code> on the dev-VM to ensure the base ideas directory exists.</p>"},{"location":"api/rest/#get-apiideasidorslug","title":"GET <code>/api/ideas/:idOrSlug</code>","text":"<p>Get a single idea by its slug or UUID. Returns the full idea including the <code>content</code> field (the original idea text from <code>idea.md</code>).</p> <p>Parameters:</p> Parameter Type Description <code>idOrSlug</code> string The idea's slug (e.g., <code>my-cool-idea</code>) or UUID <p>Response (200 OK):</p> <pre><code>{\n  \"ok\": true,\n  \"data\": {\n    \"id\": \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\",\n    \"slug\": \"my-cool-idea\",\n    \"title\": \"My Cool Idea\",\n    \"status\": \"chatting\",\n    \"sessionId\": \"sess_01J5XYZ...\",\n    \"createdAt\": \"2025-01-15T10:30:00.000Z\",\n    \"updatedAt\": \"2025-01-15T11:45:00.000Z\",\n    \"content\": \"A web app that does X, Y, and Z. The main goal is to solve...\"\n  }\n}\n</code></pre> <p>Response (404 Not Found):</p> <pre><code>{\n  \"ok\": false,\n  \"error\": \"Idea not found\"\n}\n</code></pre> <p>Lookup strategy: The backend first tries to read <code>$IDEAS_BASE_PATH/&lt;idOrSlug&gt;/meta.json</code> (treating the parameter as a slug). If that fails, it uses <code>grep -rl</code> to search all <code>meta.json</code> files for a matching <code>id</code> field.</p>"},{"location":"api/rest/#patch-apiideasidorslug","title":"PATCH <code>/api/ideas/:idOrSlug</code>","text":"<p>Update an idea's metadata. Only the provided fields are changed; others are preserved.</p> <p>Parameters:</p> Parameter Type Description <code>idOrSlug</code> string The idea's slug or UUID <p>Request:</p> <pre><code>{\n  \"title\": \"Updated Title\",\n  \"status\": \"done\",\n  \"sessionId\": \"sess_01NEWID...\"\n}\n</code></pre> <p>All fields are optional. Updatable fields:</p> Field Type Description <code>title</code> string New title for the idea <code>status</code> <code>\"captured\" \\| \"chatting\" \\| \"building\" \\| \"done\"</code> New status <code>sessionId</code> string Claude session ID <p>Response (200 OK):</p> <pre><code>{\n  \"ok\": true,\n  \"data\": {\n    \"id\": \"a1b2c3d4-...\",\n    \"slug\": \"my-cool-idea\",\n    \"title\": \"Updated Title\",\n    \"status\": \"done\",\n    \"sessionId\": \"sess_01NEWID...\",\n    \"createdAt\": \"2025-01-15T10:30:00.000Z\",\n    \"updatedAt\": \"2025-01-15T12:00:00.000Z\"\n  }\n}\n</code></pre> <p>The <code>updatedAt</code> timestamp is automatically set to the current time.</p> <p>Response (404 Not Found):</p> <pre><code>{\n  \"ok\": false,\n  \"error\": \"Idea not found\"\n}\n</code></pre> <p>Note</p> <p>The slug is not updated when the title changes. Slugs are immutable after creation.</p>"},{"location":"api/rest/#delete-apiideasidorslug","title":"DELETE <code>/api/ideas/:idOrSlug</code>","text":"<p>Delete an idea and all its files (metadata, content, and project directory) from the dev-VM.</p> <p>Parameters:</p> Parameter Type Description <code>idOrSlug</code> string The idea's slug or UUID <p>Response (200 OK):</p> <pre><code>{\n  \"ok\": true\n}\n</code></pre> <p>Response (404 Not Found):</p> <pre><code>{\n  \"ok\": false,\n  \"error\": \"Idea not found\"\n}\n</code></pre> <p>Warning</p> <p>This permanently deletes the idea directory on the dev-VM using <code>rm -rf</code>, including any project files built by Claude. This action cannot be undone.</p>"},{"location":"api/rest/#error-handling","title":"Error Handling","text":"<p>All endpoints wrap their logic in try/catch blocks. Unexpected errors return a 500 response:</p> <pre><code>{\n  \"ok\": false,\n  \"error\": \"Description of the error\"\n}\n</code></pre> <p>The error message is taken from the caught exception's <code>.message</code> property.</p>"},{"location":"api/rest/#type-definitions","title":"Type Definitions","text":"<p>All request and response types are defined in <code>packages/shared/src/index.ts</code>:</p> <pre><code>export interface ApiResponse&lt;T = unknown&gt; {\n  ok: boolean;\n  data?: T;\n  error?: string;\n}\n\nexport interface AuthCheckResponse {\n  authenticated: boolean;\n}\n\nexport interface HealthResponse {\n  status: 'ok' | 'degraded';\n  ssh: boolean;\n  uptime: number;\n}\n\nexport type IdeaStatus = 'captured' | 'chatting' | 'building' | 'done';\n\nexport interface IdeaMeta {\n  id: string;\n  slug: string;\n  title: string;\n  status: IdeaStatus;\n  sessionId?: string;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface Idea extends IdeaMeta {\n  content?: string;\n}\n</code></pre>"},{"location":"api/websocket/","title":"WebSocket Protocol","text":"<p>Catalyst uses a WebSocket connection for real-time, bidirectional communication between the browser and the backend during Claude Code sessions. This page documents the connection lifecycle, authentication, and all message types.</p>"},{"location":"api/websocket/#connection","title":"Connection","text":""},{"location":"api/websocket/#url","title":"URL","text":"<pre><code>ws://localhost:3000/ws     (development, through Vite proxy)\nws://localhost:3001/ws     (development, direct to backend)\nwss://catalyst.local/ws    (production, through ingress)\n</code></pre> <p>The frontend automatically selects <code>ws:</code> or <code>wss:</code> based on the page protocol:</p> <pre><code>const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';\nconst ws = new WebSocket(`${protocol}//${window.location.host}/ws`);\n</code></pre>"},{"location":"api/websocket/#authentication","title":"Authentication","text":"<p>WebSocket authentication happens during the HTTP upgrade handshake. The backend extracts and verifies the signed <code>catalyst_session</code> cookie from the upgrade request headers.</p> <p>If authentication succeeds: The upgrade completes normally (HTTP 101 Switching Protocols).</p> <p>If authentication fails: The server responds with HTTP 401 and destroys the socket:</p> <pre><code>HTTP/1.1 401 Unauthorized\n</code></pre> <p>No WebSocket connection is established.</p> <p>Note</p> <p>The browser's WebSocket API does not allow setting custom headers. Authentication relies entirely on the cookie, which the browser sends automatically with the upgrade request.</p>"},{"location":"api/websocket/#auto-reconnect","title":"Auto-Reconnect","text":"<p>The frontend's <code>useWebSocket</code> hook implements automatic reconnection with exponential backoff:</p> <ul> <li>Initial delay: 1 second</li> <li>Backoff multiplier: 2x</li> <li>Maximum delay: 30 seconds</li> <li>Reset: The retry counter resets to 0 on a successful connection</li> </ul> <p>The connection status is tracked and displayed via the <code>ConnectionIndicator</code> component.</p>"},{"location":"api/websocket/#message-format","title":"Message Format","text":"<p>All messages (both directions) are JSON-encoded strings. Each message has a <code>type</code> field that determines its structure.</p>"},{"location":"api/websocket/#client-messages-browser-to-server","title":"Client Messages (Browser to Server)","text":"<p>The client sends three types of messages, all including an <code>ideaId</code> for routing:</p>"},{"location":"api/websocket/#chat","title":"<code>chat</code>","text":"<p>Start or continue a chat session with Claude. Claude is restricted to read-only tools (<code>Read</code>, <code>Grep</code>, <code>Glob</code>).</p> <pre><code>{\n  \"type\": \"chat\",\n  \"ideaId\": \"my-cool-idea\",\n  \"message\": \"What tech stack would work best for this?\"\n}\n</code></pre> Field Type Description <code>type</code> <code>\"chat\"</code> Message type identifier <code>ideaId</code> string The idea's slug or ID <code>message</code> string The message to send to Claude"},{"location":"api/websocket/#build","title":"<code>build</code>","text":"<p>Trigger build mode. Claude gets full tool access and works in the idea's <code>project/</code> directory.</p> <pre><code>{\n  \"type\": \"build\",\n  \"ideaId\": \"my-cool-idea\",\n  \"instructions\": \"Build this project based on our discussion. Create all necessary files.\"\n}\n</code></pre> Field Type Description <code>type</code> <code>\"build\"</code> Message type identifier <code>ideaId</code> string The idea's slug or ID <code>instructions</code> string Build instructions for Claude"},{"location":"api/websocket/#cancel","title":"<code>cancel</code>","text":"<p>Cancel the currently running Claude session for an idea.</p> <pre><code>{\n  \"type\": \"cancel\",\n  \"ideaId\": \"my-cool-idea\"\n}\n</code></pre> Field Type Description <code>type</code> <code>\"cancel\"</code> Message type identifier <code>ideaId</code> string The idea's slug or ID <p>The backend sends <code>SIGINT</code> to the SSH channel, followed by <code>SIGKILL</code> after 5 seconds if the process is still running.</p>"},{"location":"api/websocket/#server-messages-server-to-browser","title":"Server Messages (Server to Browser)","text":"<p>The server sends six types of messages, all including an <code>ideaId</code> for client-side routing:</p>"},{"location":"api/websocket/#claudesystem","title":"<code>claude:system</code>","text":"<p>Sent once at the start of a Claude session. Contains the session ID and model.</p> <pre><code>{\n  \"type\": \"claude:system\",\n  \"ideaId\": \"my-cool-idea\",\n  \"sessionId\": \"sess_01J5XYZ...\",\n  \"model\": \"claude-sonnet-4-20250514\"\n}\n</code></pre> Field Type Description <code>type</code> <code>\"claude:system\"</code> Message type identifier <code>ideaId</code> string The idea this session belongs to <code>sessionId</code> string Claude's session ID, used for resumption <code>model</code> string The Claude model being used <p>When the frontend receives this message, it sets the <code>streaming</code> state to <code>true</code> and clears the stream buffer.</p>"},{"location":"api/websocket/#claudetext","title":"<code>claude:text</code>","text":"<p>A chunk of text from Claude's response. These arrive incrementally as Claude generates tokens.</p> <pre><code>{\n  \"type\": \"claude:text\",\n  \"ideaId\": \"my-cool-idea\",\n  \"text\": \"Here's my analysis of \"\n}\n</code></pre> Field Type Description <code>type</code> <code>\"claude:text\"</code> Message type identifier <code>ideaId</code> string The idea this response belongs to <code>text</code> string A text chunk (may be a partial word, sentence, or paragraph) <p>The frontend accumulates these chunks in a <code>streamBuffer</code> state variable and renders them with Markdown formatting as they arrive.</p>"},{"location":"api/websocket/#claudetool_use","title":"<code>claude:tool_use</code>","text":"<p>Claude is invoking a tool. Sent before the tool executes.</p> <pre><code>{\n  \"type\": \"claude:tool_use\",\n  \"ideaId\": \"my-cool-idea\",\n  \"toolUseId\": \"tu_01ABC...\",\n  \"name\": \"Read\",\n  \"input\": {\n    \"file_path\": \"/home/user/project/src/index.ts\"\n  }\n}\n</code></pre> Field Type Description <code>type</code> <code>\"claude:tool_use\"</code> Message type identifier <code>ideaId</code> string The idea this tool use belongs to <code>toolUseId</code> string Unique identifier for this tool invocation <code>name</code> string Tool name (e.g., <code>Read</code>, <code>Grep</code>, <code>Glob</code>, <code>Write</code>, <code>Bash</code>) <code>input</code> object Tool input parameters (varies by tool) <p>The frontend adds an entry to the tool activity panel. Tool activities are collapsible and show both the input and result.</p>"},{"location":"api/websocket/#claudetool_result","title":"<code>claude:tool_result</code>","text":"<p>The result of a tool execution, matched to a previous <code>tool_use</code> by <code>toolUseId</code>.</p> <pre><code>{\n  \"type\": \"claude:tool_result\",\n  \"ideaId\": \"my-cool-idea\",\n  \"toolUseId\": \"tu_01ABC...\",\n  \"content\": \"import express from 'express';\\nimport { config } from './config.js';\\n...\"\n}\n</code></pre> Field Type Description <code>type</code> <code>\"claude:tool_result\"</code> Message type identifier <code>ideaId</code> string The idea this result belongs to <code>toolUseId</code> string Matches the <code>toolUseId</code> from the corresponding <code>tool_use</code> message <code>content</code> string The tool's output (file contents, search results, command output, etc.)"},{"location":"api/websocket/#clauderesult","title":"<code>claude:result</code>","text":"<p>Sent once at the end of a Claude interaction. Contains the final result, session ID, and usage metrics.</p> <pre><code>{\n  \"type\": \"claude:result\",\n  \"ideaId\": \"my-cool-idea\",\n  \"result\": \"I've completed the analysis. Here's a summary...\",\n  \"sessionId\": \"sess_01J5XYZ...\",\n  \"costUsd\": 0.042,\n  \"durationMs\": 15234,\n  \"turns\": 3\n}\n</code></pre> Field Type Description <code>type</code> <code>\"claude:result\"</code> Message type identifier <code>ideaId</code> string The idea this result belongs to <code>result</code> string? The final response text (present on success) <code>error</code> string? Error description (present on failure) <code>sessionId</code> string The session ID for resumption <code>costUsd</code> number Total cost of this interaction in USD <code>durationMs</code> number Total duration in milliseconds <code>turns</code> number Number of conversational turns <p>When the frontend receives this message, it:</p> <ol> <li>Adds the accumulated <code>streamBuffer</code> (or the <code>result</code> field) as an assistant message.</li> <li>Clears the stream buffer and sets <code>streaming</code> to <code>false</code>.</li> <li>Refetches the idea metadata to pick up any status changes.</li> </ol>"},{"location":"api/websocket/#claudeerror","title":"<code>claude:error</code>","text":"<p>An error occurred during the Claude interaction.</p> <pre><code>{\n  \"type\": \"claude:error\",\n  \"ideaId\": \"my-cool-idea\",\n  \"error\": \"SSH connection failed\"\n}\n</code></pre> Field Type Description <code>type</code> <code>\"claude:error\"</code> Message type identifier <code>ideaId</code> string The idea that encountered the error <code>error</code> string Human-readable error description <p>Common errors:</p> <ul> <li><code>\"Idea not found: &lt;id&gt;\"</code> -- The idea does not exist on the dev-VM</li> <li><code>\"SSH connection failed\"</code> -- Cannot connect to the dev-VM</li> <li><code>\"SSH connection pool exhausted\"</code> -- All connections are busy</li> <li><code>\"Claude process timed out (no output for 10 minutes)\"</code> -- Inactivity timeout</li> <li><code>\"Chat failed\"</code> / <code>\"Build failed\"</code> -- Generic catch-all errors</li> </ul>"},{"location":"api/websocket/#message-flow-example","title":"Message Flow Example","text":"<p>Here is a complete message flow for a chat interaction:</p> <pre><code>sequenceDiagram\n    participant Browser\n    participant Backend\n    participant DevVM as Dev-VM (Claude)\n\n    Browser-&gt;&gt;Backend: {\"type\":\"chat\",\"ideaId\":\"my-idea\",\"message\":\"How should I structure this?\"}\n    Backend-&gt;&gt;DevVM: SSH exec: claude -p \"...\" --output-format stream-json --resume sess_01...\n    DevVM--&gt;&gt;Backend: {\"type\":\"system\",\"subtype\":\"init\",\"session_id\":\"sess_01...\",\"model\":\"claude-sonnet-4-20250514\"}\n    Backend--&gt;&gt;Browser: {\"type\":\"claude:system\",\"ideaId\":\"my-idea\",\"sessionId\":\"sess_01...\",\"model\":\"...\"}\n    DevVM--&gt;&gt;Backend: {\"type\":\"assistant\",\"subtype\":\"text\",\"text\":\"I'd recommend \"}\n    Backend--&gt;&gt;Browser: {\"type\":\"claude:text\",\"ideaId\":\"my-idea\",\"text\":\"I'd recommend \"}\n    DevVM--&gt;&gt;Backend: {\"type\":\"assistant\",\"subtype\":\"text\",\"text\":\"structuring it as...\"}\n    Backend--&gt;&gt;Browser: {\"type\":\"claude:text\",\"ideaId\":\"my-idea\",\"text\":\"structuring it as...\"}\n    DevVM--&gt;&gt;Backend: {\"type\":\"assistant\",\"subtype\":\"tool_use\",\"name\":\"Read\",\"input\":{\"file_path\":\"...\"}}\n    Backend--&gt;&gt;Browser: {\"type\":\"claude:tool_use\",\"ideaId\":\"my-idea\",\"name\":\"Read\",\"input\":{...}}\n    DevVM--&gt;&gt;Backend: {\"type\":\"tool_result\",\"tool_use_id\":\"tu_01...\",\"content\":\"...\"}\n    Backend--&gt;&gt;Browser: {\"type\":\"claude:tool_result\",\"ideaId\":\"my-idea\",\"toolUseId\":\"tu_01...\",\"content\":\"...\"}\n    DevVM--&gt;&gt;Backend: {\"type\":\"result\",\"subtype\":\"success\",\"result\":\"...\",\"cost_usd\":0.03,...}\n    Backend--&gt;&gt;Browser: {\"type\":\"claude:result\",\"ideaId\":\"my-idea\",\"result\":\"...\",\"costUsd\":0.03,...}</code></pre>"},{"location":"api/websocket/#multiplexing","title":"Multiplexing","text":"<p>All messages include an <code>ideaId</code> field. The frontend filters incoming messages by the current idea's ID or slug:</p> <pre><code>const onMessage = useCallback((msg: WsServerMessage) =&gt; {\n  if ('ideaId' in msg &amp;&amp; msg.ideaId !== idea?.id &amp;&amp; msg.ideaId !== idea?.slug) return;\n  // Handle message...\n}, [idea?.id, idea?.slug]);\n</code></pre> <p>This allows a single WebSocket connection to handle multiple ideas, though in practice a user typically works on one idea at a time.</p>"},{"location":"api/websocket/#type-definitions","title":"Type Definitions","text":"<p>All message types are defined in <code>packages/shared/src/index.ts</code>:</p> <pre><code>// Client -&gt; Server\nexport type WsClientMessage = WsChatMessage | WsBuildMessage | WsCancelMessage;\n\n// Server -&gt; Client\nexport type WsServerMessage =\n  | WsClaudeSystemMessage\n  | WsClaudeTextMessage\n  | WsClaudeToolUseMessage\n  | WsClaudeToolResultMessage\n  | WsClaudeResultMessage\n  | WsClaudeErrorMessage;\n</code></pre>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>Catalyst is a full-stack TypeScript application with a clear separation between its frontend, backend, and the external Claude Code process. This page describes the high-level architecture and how the pieces fit together.</p>"},{"location":"architecture/#system-diagram","title":"System Diagram","text":"<pre><code>graph LR\n    A[Phone / Browser] --&gt;|HTTPS| B[k8s Ingress&lt;br/&gt;nginx]\n    B --&gt;|HTTP + WS| C[Catalyst Pod&lt;br/&gt;Express + Static Files]\n    C --&gt;|SSH| D[Dev-VM&lt;br/&gt;Vagrant]\n    D --&gt;|subprocess| E[Claude Code CLI]\n    E --&gt;|NDJSON stdout| D\n    D --&gt;|SSH stream| C\n    C --&gt;|WebSocket| A</code></pre> <p>The data flow for a typical chat interaction:</p> <ol> <li>The user types a message in the browser.</li> <li>The frontend sends a JSON message over WebSocket to the backend.</li> <li>The backend opens an SSH channel to the dev-VM and executes the <code>claude</code> CLI with the message.</li> <li>Claude Code runs, producing NDJSON output on stdout.</li> <li>The backend reads the NDJSON stream over the SSH channel, parses each line, and translates it into WebSocket messages.</li> <li>The frontend receives these messages and renders text, tool activity, and results in real time.</li> </ol>"},{"location":"architecture/#package-architecture","title":"Package Architecture","text":"<p>Catalyst is organized as a Bun workspace monorepo with three packages:</p> <pre><code>catalyst/\n  packages/\n    shared/     # TypeScript types shared between frontend and backend\n    backend/    # Express server, SSH service, Claude service, WebSocket handler\n    frontend/   # React SPA with Vite, zustand, and shadcn/ui\n</code></pre>"},{"location":"architecture/#catalystshared","title":"@catalyst/shared","text":"<p>Contains all TypeScript interfaces and type definitions used by both sides:</p> <ul> <li>Idea types -- <code>IdeaMeta</code>, <code>Idea</code>, <code>IdeaStatus</code></li> <li>Claude stream message types -- <code>ClaudeSystemInit</code>, <code>ClaudeAssistantText</code>, <code>ClaudeToolUse</code>, <code>ClaudeToolResult</code>, <code>ClaudeResult</code></li> <li>WebSocket protocol types -- <code>WsClientMessage</code> (chat, build, cancel) and <code>WsServerMessage</code> (claude:system, claude:text, etc.)</li> <li>API response types -- <code>ApiResponse&lt;T&gt;</code>, <code>AuthCheckResponse</code>, <code>HealthResponse</code></li> </ul> <p>This package has no runtime dependencies. It is imported directly from source (<code>./src/index.ts</code>) by both the backend and frontend.</p>"},{"location":"architecture/#catalystbackend","title":"@catalyst/backend","text":"<p>The Express server that handles:</p> <ul> <li>Authentication -- Shared secret login, signed cookie sessions, in-memory token store</li> <li>REST API -- CRUD operations on ideas (via SSH filesystem commands on the dev-VM)</li> <li>WebSocket server -- Real-time bidirectional communication for Claude interactions</li> <li>SSH connection pooling -- Manages a pool of persistent SSH connections to the dev-VM</li> <li>Claude orchestration -- Invokes <code>claude</code> CLI over SSH, parses NDJSON output, relays events</li> </ul>"},{"location":"architecture/#catalystfrontend","title":"@catalyst/frontend","text":"<p>A React 18 SPA built with Vite:</p> <ul> <li>Pages -- Login, Dashboard, Capture, Session</li> <li>State management -- zustand stores for auth and connection status</li> <li>Real-time -- Custom <code>useWebSocket</code> hook with auto-reconnect and exponential backoff</li> <li>UI -- Tailwind CSS 4 with shadcn/ui components, Markdown rendering with syntax highlighting</li> </ul>"},{"location":"architecture/#authentication-flow","title":"Authentication Flow","text":"<p>Catalyst uses a single shared secret for authentication, appropriate for a personal single-user application:</p> <pre><code>sequenceDiagram\n    participant Browser\n    participant Backend\n\n    Browser-&gt;&gt;Backend: POST /api/login { secret }\n    Backend-&gt;&gt;Backend: Timing-safe comparison\n    Backend-&gt;&gt;Browser: Set signed cookie (30 days)\n    Browser-&gt;&gt;Backend: GET /api/auth/check\n    Backend-&gt;&gt;Browser: { authenticated: true }\n    Browser-&gt;&gt;Backend: WS upgrade /ws\n    Backend-&gt;&gt;Backend: Extract &amp; verify cookie from upgrade headers\n    Backend-&gt;&gt;Browser: 101 Switching Protocols</code></pre> <p>The session token is a random 32-byte hex string stored in an <code>httpOnly</code>, <code>signed</code>, <code>secure</code> (in production), <code>sameSite: strict</code> cookie. The token is held in an in-memory <code>Set</code> on the backend. This means sessions do not survive server restarts, which is acceptable for a single-user app.</p> <p>WebSocket authentication happens during the HTTP upgrade. The backend manually parses and unsigns the cookie from the <code>Upgrade</code> request headers, since Express middleware does not run on WebSocket upgrades.</p>"},{"location":"architecture/#idea-lifecycle","title":"Idea Lifecycle","text":"<p>Each idea progresses through four statuses:</p> Status Description Claude Tools Available <code>captured</code> Idea has been created but no Claude interaction yet -- <code>chatting</code> User is refining the idea with Claude <code>Read</code>, <code>Grep</code>, <code>Glob</code> (read-only) <code>building</code> Claude is building the project with full tool access All tools <code>done</code> Build complete -- <p>The status transitions are managed by the backend. When the user sends a <code>chat</code> message, the status moves from <code>captured</code> to <code>chatting</code>. When they send a <code>build</code> message, it moves to <code>building</code>. The transition to <code>done</code> is not currently automated -- it can be set via the PATCH endpoint.</p>"},{"location":"architecture/#network-security","title":"Network Security","text":"<p>In the Kubernetes deployment, a <code>NetworkPolicy</code> restricts the Catalyst pod's traffic:</p> <ul> <li>Ingress -- Only from the ingress-nginx namespace</li> <li>Egress -- DNS (port 53) and SSH to the dev-VM (configurable CIDR)</li> </ul> <p>This means the pod cannot make arbitrary outbound connections. It can only resolve DNS and reach the dev-VM over SSH.</p>"},{"location":"architecture/backend/","title":"Backend Architecture","text":"<p>The Catalyst backend is an Express 4 server written in TypeScript, running on Bun. It handles authentication, serves the REST API for ideas, manages SSH connections to the dev-VM, orchestrates Claude Code sessions, and runs the WebSocket server for real-time streaming.</p>"},{"location":"architecture/backend/#entry-point","title":"Entry Point","text":"<p>The server is defined in <code>packages/backend/src/index.ts</code>. At startup, it:</p> <ol> <li>Creates an Express app with JSON body parsing and cookie parsing.</li> <li>Registers the health endpoint (unauthenticated).</li> <li>Mounts the auth router (<code>/api/login</code>, <code>/api/logout</code>, <code>/api/auth/check</code>).</li> <li>Mounts the ideas router (<code>/api/ideas/*</code>) behind the <code>requireAuth</code> middleware.</li> <li>In production, serves the frontend static files with SPA fallback.</li> <li>Starts the HTTP server on the configured port (default <code>3001</code>).</li> <li>Attaches the WebSocket server to the same HTTP server.</li> <li>Registers a <code>SIGTERM</code> handler for graceful shutdown.</li> </ol> <pre><code>const server = app.listen(config.port, () =&gt; {\n  console.log(`Catalyst backend listening on :${config.port}`);\n});\n\nsetupWebSocket(server);\n\nprocess.on('SIGTERM', () =&gt; {\n  sshService.closeAll();\n  server.close(() =&gt; process.exit(0));\n});\n</code></pre>"},{"location":"architecture/backend/#ssh-service","title":"SSH Service","text":"<p>File: <code>packages/backend/src/services/ssh.ts</code></p> <p>The SSH service manages a pool of persistent SSH connections to the dev-VM using the <code>ssh2</code> library. This avoids the overhead of establishing a new SSH handshake for every operation.</p>"},{"location":"architecture/backend/#connection-pooling","title":"Connection Pooling","text":"<p>The pool has a configurable maximum size (<code>MAX_SSH_CONNECTIONS</code>, default 3). When a connection is requested:</p> <ol> <li>If an idle connection exists in the pool, it is marked as busy and returned.</li> <li>If the pool is not full, a new connection is created, added to the pool, and returned.</li> <li>If the pool is full and all connections are busy, the request waits (polling every 100ms) until one becomes available or a 10-second timeout is reached.</li> </ol> <pre><code>async getConnection(): Promise&lt;Client&gt; {\n  const idle = this.pool.find((c) =&gt; !c.busy);\n  if (idle) {\n    idle.busy = true;\n    idle.lastUsed = Date.now();\n    return idle.client;\n  }\n  if (this.pool.length &lt; config.maxSshConnections) {\n    const client = await this.connect();\n    // ...\n  }\n  // Wait for one to free up...\n}\n</code></pre> <p>Connections are configured with keepalive (<code>keepaliveInterval: 15000</code>, <code>keepaliveCountMax: 3</code>) to detect and remove dead connections. When a connection errors or closes, it is automatically removed from the pool.</p>"},{"location":"architecture/backend/#two-execution-modes","title":"Two Execution Modes","text":"<p>The SSH service provides two methods for running commands:</p> <ul> <li><code>exec(command)</code> -- Runs a command and returns the full stdout as a string. Used for filesystem operations (listing ideas, reading files, creating directories).</li> <li><code>execStream(command, callbacks)</code> -- Runs a command and streams output via callbacks (<code>onData</code>, <code>onError</code>, <code>onClose</code>). Returns the SSH channel, allowing the caller to send signals. Used for Claude Code sessions.</li> </ul>"},{"location":"architecture/backend/#ideas-service","title":"Ideas Service","text":"<p>File: <code>packages/backend/src/services/ideas.ts</code></p> <p>The ideas service performs CRUD operations on idea data stored on the dev-VM's filesystem. All file operations happen over SSH -- the backend does not have direct filesystem access to the dev-VM.</p>"},{"location":"architecture/backend/#storage-format","title":"Storage Format","text":"<p>Each idea is a directory under <code>IDEAS_BASE_PATH</code>:</p> <pre><code>~/catalyst/ideas/\n  my-idea-slug/\n    meta.json    # IdeaMeta as JSON\n    idea.md      # Original idea content\n    project/     # Created during build mode\n</code></pre>"},{"location":"architecture/backend/#operations","title":"Operations","text":"Method SSH Command Description <code>list()</code> <code>find $BASE -maxdepth 2 -name meta.json -exec cat {} \\;</code> Lists all ideas by reading every <code>meta.json</code> <code>get(idOrSlug)</code> <code>cat $DIR/meta.json</code> and <code>cat $DIR/idea.md</code> Gets a single idea by slug, falls back to grep-by-ID <code>create(title, content)</code> <code>mkdir -p $DIR &amp;&amp; echo ... &gt; meta.json &amp;&amp; echo ... &gt; idea.md</code> Creates a new idea directory with metadata and content <code>update(idOrSlug, updates)</code> <code>echo ... &gt; $DIR/meta.json</code> Patches metadata fields (title, status, sessionId) <code>delete(idOrSlug)</code> <code>rm -rf $DIR</code> Removes the entire idea directory <p>Slugs are generated from the title using the <code>slugify</code> library (lowercase, strict mode). IDs are UUIDv4.</p>"},{"location":"architecture/backend/#lookup-strategy","title":"Lookup Strategy","text":"<p>When looking up an idea by <code>idOrSlug</code>, the service first tries to interpret the parameter as a slug (attempting to <code>cat</code> the <code>meta.json</code> at that path). If that fails, it falls back to searching all <code>meta.json</code> files for a matching <code>id</code> field using <code>grep -rl</code>.</p>"},{"location":"architecture/backend/#claude-service","title":"Claude Service","text":"<p>File: <code>packages/backend/src/services/claude.ts</code></p> <p>The Claude service orchestrates Claude Code sessions. It builds the CLI command, runs it over SSH, and parses the NDJSON output stream. See the dedicated Claude Integration page for details on the stream protocol and command structure.</p>"},{"location":"architecture/backend/#chat-vs-build","title":"Chat vs Build","text":"<p>The service exposes two methods:</p> <ul> <li><code>chat(ideaId, message, callbacks)</code> -- Invokes Claude with <code>--allowedTools 'Read,Grep,Glob'</code>, restricting it to read-only operations. Updates the idea status to <code>chatting</code>.</li> <li><code>build(ideaId, instructions, callbacks)</code> -- Invokes Claude with no tool restrictions, inside a <code>project/</code> subdirectory under the idea. Updates the idea status to <code>building</code>.</li> </ul> <p>Both methods resume from the existing session ID if one is stored on the idea's metadata, enabling conversation continuity.</p>"},{"location":"architecture/backend/#cancellation","title":"Cancellation","text":"<p>Active Claude sessions are tracked in a <code>Map&lt;string, ClientChannel&gt;</code> keyed by idea ID. The <code>cancel(ideaId)</code> method sends <code>SIGINT</code> to the SSH channel. If the process is still running after 5 seconds, it sends <code>SIGKILL</code>.</p>"},{"location":"architecture/backend/#timeout","title":"Timeout","text":"<p>A timeout mechanism monitors the last output timestamp. If Claude produces no output for <code>CLAUDE_TIMEOUT_MS</code> (default 10 minutes), the process is automatically cancelled and an error is reported to the client.</p>"},{"location":"architecture/backend/#websocket-handler","title":"WebSocket Handler","text":"<p>File: <code>packages/backend/src/ws.ts</code></p> <p>The WebSocket server is created with <code>{ noServer: true }</code> and attached to the HTTP server's <code>upgrade</code> event. This allows the backend to authenticate the request before completing the upgrade.</p>"},{"location":"architecture/backend/#authentication-on-upgrade","title":"Authentication on Upgrade","text":"<pre><code>server.on('upgrade', (req, socket, head) =&gt; {\n  const token = extractToken(req);\n  if (!token || !verifyToken(token)) {\n    socket.write('HTTP/1.1 401 Unauthorized\\r\\n\\r\\n');\n    socket.destroy();\n    return;\n  }\n  wss.handleUpgrade(req, socket, head, (ws) =&gt; {\n    wss.emit('connection', ws, req);\n  });\n});\n</code></pre> <p>Cookie extraction is done manually since Express middleware does not run on upgrade requests. The signed cookie is parsed from the <code>Cookie</code> header, the HMAC signature is verified against <code>COOKIE_SECRET</code>, and the token is checked against the in-memory token set.</p>"},{"location":"architecture/backend/#message-routing","title":"Message Routing","text":"<p>Incoming WebSocket messages are parsed as JSON and dispatched based on their <code>type</code> field:</p> Client Message Type Handler Description <code>chat</code> <code>handleChat()</code> Starts or continues a chat session <code>build</code> <code>handleBuild()</code> Triggers build mode for an idea <code>cancel</code> <code>claudeService.cancel()</code> Cancels the active Claude session <p>Server messages are sent back using a <code>sendMessage()</code> helper that checks <code>ws.readyState</code> before sending. All messages include an <code>ideaId</code> field for client-side multiplexing.</p>"},{"location":"architecture/backend/#health-endpoint","title":"Health Endpoint","text":"<p>The <code>GET /api/health</code> endpoint is unauthenticated and returns the server's health status including SSH connectivity:</p> <pre><code>{\n  \"status\": \"ok\",\n  \"ssh\": true,\n  \"uptime\": 42.5\n}\n</code></pre> <p>If no SSH connections exist yet, it attempts a quick <code>echo ok</code> command to test connectivity. The status is <code>\"ok\"</code> when SSH is healthy, <code>\"degraded\"</code> when it is not. This endpoint is used by the Kubernetes liveness and readiness probes.</p>"},{"location":"architecture/claude-integration/","title":"Claude Integration","text":"<p>Catalyst integrates with Claude Code by invoking the <code>claude</code> CLI over SSH on the dev-VM. This page explains the command structure, stream protocol, interaction modes, and how sessions are managed.</p>"},{"location":"architecture/claude-integration/#how-claude-code-is-invoked","title":"How Claude Code is Invoked","text":"<p>When a user sends a chat message or triggers a build, the backend constructs a <code>claude</code> CLI command and executes it over an SSH channel on the dev-VM. The command follows this structure:</p> <pre><code>claude -p &lt;message&gt; --output-format stream-json [--resume &lt;session-id&gt;] [--allowedTools &lt;tools&gt;] [--project-dir &lt;dir&gt;]\n</code></pre>"},{"location":"architecture/claude-integration/#command-flags","title":"Command Flags","text":"Flag Description <code>-p &lt;message&gt;</code> The prompt message to send to Claude. The <code>p</code> flag runs Claude in non-interactive (pipe) mode. <code>--output-format stream-json</code> Tells Claude to output NDJSON (newline-delimited JSON) to stdout, one JSON object per line. <code>--resume &lt;session-id&gt;</code> Resumes an existing Claude session. Omitted for the first interaction with a new idea. <code>--allowedTools &lt;tools&gt;</code> Comma-separated list of tools Claude is allowed to use. Used in chat mode to restrict to read-only tools. <code>--project-dir &lt;dir&gt;</code> Sets Claude's working directory. Used in build mode to point at the idea's <code>project/</code> subdirectory."},{"location":"architecture/claude-integration/#command-construction","title":"Command Construction","text":"<p>The backend builds the command in <code>packages/backend/src/services/claude.ts</code>:</p> <pre><code>function buildClaudeCommand(opts: {\n  message: string;\n  sessionId?: string;\n  allowedTools?: string;\n  projectDir?: string;\n}): string {\n  const parts = ['claude', '-p', escapeForShell(opts.message),\n                  '--output-format', 'stream-json'];\n\n  if (opts.sessionId) parts.push('--resume', opts.sessionId);\n  if (opts.allowedTools) parts.push('--allowedTools', escapeForShell(opts.allowedTools));\n  if (opts.projectDir) parts.push('--project-dir', opts.projectDir);\n\n  return parts.join(' ');\n}\n</code></pre> <p>Shell escaping uses <code>$'...'</code> quoting to safely handle special characters in messages.</p>"},{"location":"architecture/claude-integration/#ndjson-stream-protocol","title":"NDJSON Stream Protocol","text":"<p>Claude Code outputs one JSON object per line to stdout. Each line is a <code>ClaudeStreamMessage</code> with a <code>type</code> field that determines the message structure.</p>"},{"location":"architecture/claude-integration/#message-types","title":"Message Types","text":""},{"location":"architecture/claude-integration/#system-subtype-init","title":"<code>system</code> (subtype: <code>init</code>)","text":"<p>Sent once at the start of a session. Contains the session ID, available tools, and model name.</p> <pre><code>{\n  \"type\": \"system\",\n  \"subtype\": \"init\",\n  \"session_id\": \"sess_01J5XYZ...\",\n  \"tools\": [\"Read\", \"Write\", \"Bash\", \"Grep\", \"Glob\"],\n  \"model\": \"claude-sonnet-4-20250514\"\n}\n</code></pre> <p>When the backend receives this message, it persists the <code>session_id</code> to the idea's <code>meta.json</code> so future interactions can resume the session.</p>"},{"location":"architecture/claude-integration/#assistant-subtype-text","title":"<code>assistant</code> (subtype: <code>text</code>)","text":"<p>A chunk of text from Claude's response. These arrive incrementally as Claude generates tokens.</p> <pre><code>{\n  \"type\": \"assistant\",\n  \"subtype\": \"text\",\n  \"text\": \"Here's my analysis of \"\n}\n</code></pre> <p>The backend relays these as <code>claude:text</code> WebSocket messages. The frontend accumulates them in a stream buffer for live rendering.</p>"},{"location":"architecture/claude-integration/#assistant-subtype-tool_use","title":"<code>assistant</code> (subtype: <code>tool_use</code>)","text":"<p>Claude has decided to use a tool. Sent before the tool executes.</p> <pre><code>{\n  \"type\": \"assistant\",\n  \"subtype\": \"tool_use\",\n  \"tool_use_id\": \"tu_01ABC...\",\n  \"name\": \"Read\",\n  \"input\": {\n    \"file_path\": \"/home/user/project/src/index.ts\"\n  }\n}\n</code></pre>"},{"location":"architecture/claude-integration/#tool_result","title":"<code>tool_result</code>","text":"<p>The result of a tool execution.</p> <pre><code>{\n  \"type\": \"tool_result\",\n  \"subtype\": \"result\",\n  \"tool_use_id\": \"tu_01ABC...\",\n  \"content\": \"import express from 'express';\\n...\"\n}\n</code></pre>"},{"location":"architecture/claude-integration/#result","title":"<code>result</code>","text":"<p>Sent once at the end of the interaction. Contains a summary, the session ID, cost, duration, and turn count.</p> <p>Success:</p> <pre><code>{\n  \"type\": \"result\",\n  \"subtype\": \"success\",\n  \"result\": \"I've analyzed the codebase and here are my findings...\",\n  \"session_id\": \"sess_01J5XYZ...\",\n  \"cost_usd\": 0.042,\n  \"duration_ms\": 15234,\n  \"turns\": 3\n}\n</code></pre> <p>Error:</p> <pre><code>{\n  \"type\": \"result\",\n  \"subtype\": \"error\",\n  \"error\": \"Context window exceeded\",\n  \"session_id\": \"sess_01J5XYZ...\",\n  \"cost_usd\": 0.012,\n  \"duration_ms\": 5000,\n  \"turns\": 1\n}\n</code></pre>"},{"location":"architecture/claude-integration/#stream-parsing","title":"Stream Parsing","text":"<p>The backend parses the NDJSON stream using a buffered line parser. Because SSH delivers data in arbitrary chunks (not aligned to line boundaries), the parser maintains a buffer and splits on newlines:</p> <pre><code>function parseNdjsonStream(callbacks: ClaudeCallbacks): (data: string) =&gt; void {\n  let buffer = '';\n\n  return (data: string) =&gt; {\n    buffer += data;\n    const lines = buffer.split('\\n');\n    buffer = lines.pop() ?? '';  // Keep incomplete line in buffer\n\n    for (const line of lines) {\n      const trimmed = line.trim();\n      if (!trimmed) continue;\n\n      try {\n        const msg: ClaudeStreamMessage = JSON.parse(trimmed);\n        // Dispatch based on msg.type...\n      } catch {\n        // Non-JSON line, skip\n      }\n    }\n  };\n}\n</code></pre>"},{"location":"architecture/claude-integration/#chat-mode-vs-build-mode","title":"Chat Mode vs Build Mode","text":"<p>Catalyst enforces two distinct interaction modes, each with different tool permissions:</p>"},{"location":"architecture/claude-integration/#chat-mode","title":"Chat Mode","text":"<p>Purpose: Explore and refine the idea with Claude. Safe for brainstorming -- Claude cannot modify anything.</p> <p>Allowed tools: <code>Read</code>, <code>Grep</code>, <code>Glob</code></p> <p>Invoked by: The <code>chat</code> WebSocket message type.</p> <pre><code>claude -p \"What tech stack would work best for this?\" \\\n  --output-format stream-json \\\n  --resume sess_01J5XYZ... \\\n  --allowedTools 'Read,Grep,Glob'\n</code></pre> <p>When chat mode starts, the idea status is updated from <code>captured</code> to <code>chatting</code> (only on the first chat interaction).</p>"},{"location":"architecture/claude-integration/#build-mode","title":"Build Mode","text":"<p>Purpose: Claude creates the actual project with full access to all tools, including file writing, command execution, and more.</p> <p>Allowed tools: All (no <code>--allowedTools</code> flag).</p> <p>Invoked by: The <code>build</code> WebSocket message type.</p> <pre><code>claude -p \"Build this project based on our discussion...\" \\\n  --output-format stream-json \\\n  --resume sess_01J5XYZ... \\\n  --project-dir ~/catalyst/ideas/my-idea/project\n</code></pre> <p>Before invoking Claude, the backend creates the <code>project/</code> subdirectory under the idea folder. The idea status is updated to <code>building</code>.</p>"},{"location":"architecture/claude-integration/#session-persistence","title":"Session Persistence","text":"<p>Claude Code sessions are identified by a session ID (e.g., <code>sess_01J5XYZ...</code>). Catalyst persists this ID in the idea's <code>meta.json</code> after receiving the <code>system:init</code> message:</p> <pre><code>onSystem: (sessionId, model) =&gt; {\n  ideasService.update(ideaId, { sessionId }).catch(() =&gt; {});\n  callbacks.onSystem(sessionId, model);\n},\n</code></pre> <p>On subsequent interactions with the same idea, the stored <code>sessionId</code> is passed via <code>--resume</code>, allowing Claude to continue the conversation with full context of previous messages.</p> <p>This means:</p> <ul> <li>You can close the browser, reopen it days later, and pick up exactly where you left off.</li> <li>Chat context carries into build mode -- Claude remembers the refinement discussion when building.</li> <li>Each idea has its own independent session.</li> </ul>"},{"location":"architecture/claude-integration/#timeout-handling","title":"Timeout Handling","text":"<p>Long-running Claude processes are monitored for activity. The backend tracks the timestamp of the last output received from the SSH stream. A check runs every 30 seconds:</p> <pre><code>const timeoutCheck = setInterval(() =&gt; {\n  if (Date.now() - lastOutput &gt; config.claudeTimeout) {\n    clearInterval(timeoutCheck);\n    this.cancel(ideaId);\n    callbacks.onError('Claude process timed out (no output for 10 minutes)');\n  }\n}, 30000);\n</code></pre> <p>The default timeout is 10 minutes (<code>CLAUDE_TIMEOUT_MS=600000</code>). This is per-output, not per-session -- if Claude is actively producing output (even tool results), the timeout resets. It only triggers when Claude goes completely silent.</p>"},{"location":"architecture/claude-integration/#cancellation","title":"Cancellation","text":"<p>Users can cancel an in-progress Claude session from the UI. The cancellation flow:</p> <ol> <li>Frontend sends <code>{ type: \"cancel\", ideaId: \"...\" }</code> over WebSocket.</li> <li>Backend looks up the active SSH channel for that idea.</li> <li>Sends <code>SIGINT</code> to the channel (equivalent to Ctrl+C).</li> <li>If the process is still alive after 5 seconds, sends <code>SIGKILL</code>.</li> <li>The channel's <code>onClose</code> callback fires, cleaning up the tracking map.</li> </ol> <pre><code>cancel(ideaId: string): void {\n  const channel = activeChannels.get(ideaId);\n  if (channel) {\n    channel.signal('INT');\n    setTimeout(() =&gt; {\n      if (activeChannels.has(ideaId)) {\n        channel.signal('KILL');\n        activeChannels.delete(ideaId);\n      }\n    }, 5000);\n  }\n}\n</code></pre>"},{"location":"architecture/frontend/","title":"Frontend Architecture","text":"<p>The Catalyst frontend is a React 18 single-page application built with Vite, styled with Tailwind CSS 4 and shadcn/ui components, and powered by zustand for state management. It is designed mobile-first for quick idea capture from a phone.</p>"},{"location":"architecture/frontend/#build-tooling","title":"Build Tooling","text":"<p>The frontend uses Vite 5 with the following plugins:</p> <ul> <li><code>@vitejs/plugin-react</code> -- React Fast Refresh for HMR</li> <li><code>@tailwindcss/vite</code> -- Tailwind CSS 4 integration</li> </ul> <p>Path aliases are configured so <code>@/</code> maps to the <code>src/</code> directory:</p> <pre><code>// vite.config.ts\nresolve: {\n  alias: {\n    '@': path.resolve(__dirname, './src'),\n  },\n}\n</code></pre> <p>During development, Vite proxies API and WebSocket requests to the backend:</p> <pre><code>server: {\n  proxy: {\n    '/api': { target: 'http://localhost:3001', changeOrigin: true },\n    '/ws': { target: 'ws://localhost:3001', ws: true },\n  },\n}\n</code></pre>"},{"location":"architecture/frontend/#application-structure","title":"Application Structure","text":""},{"location":"architecture/frontend/#entry-point","title":"Entry Point","text":"<p><code>src/main.tsx</code> renders the root <code>&lt;App&gt;</code> component inside <code>React.StrictMode</code> with <code>BrowserRouter</code> for client-side routing. It also registers a service worker for potential offline support.</p>"},{"location":"architecture/frontend/#routing","title":"Routing","text":"Route Component Auth Required Description <code>/login</code> <code>LoginPage</code> No Secret-based authentication <code>/</code> <code>DashboardPage</code> Yes List of all ideas with status badges <code>/capture</code> <code>CapturePage</code> Yes Form to create a new idea <code>/idea/:slug</code> <code>SessionPage</code> Yes Chat and build interface for an idea <p>Protected routes are wrapped in an <code>AuthGuard</code> component that checks authentication status on mount and redirects to <code>/login</code> if the user is not authenticated.</p> <pre><code>function AuthGuard({ children }: { children: React.ReactNode }) {\n  const { authenticated, checking } = useAuthStore();\n\n  React.useEffect(() =&gt; {\n    useAuthStore.getState().check();\n  }, []);\n\n  if (checking) return &lt;Spinner /&gt;;\n  if (!authenticated) return &lt;Navigate to=\"/login\" replace /&gt;;\n  return &lt;&gt;{children}&lt;/&gt;;\n}\n</code></pre>"},{"location":"architecture/frontend/#layout","title":"Layout","text":"<p>The <code>Layout</code> component provides navigation structure:</p> <ul> <li>Desktop -- A narrow 64px sidebar on the left with icon buttons for Home, Capture, and Logout, plus a connection status indicator at the bottom.</li> <li>Mobile -- A fixed bottom navigation bar with the same items.</li> </ul> <p>The main content area fills the remaining space. On mobile, bottom padding accounts for the nav bar and the safe area inset.</p>"},{"location":"architecture/frontend/#pages","title":"Pages","text":""},{"location":"architecture/frontend/#login-page","title":"Login Page","text":"<p>A minimal centered form with a password input and submit button. Uses <code>useAuthStore.login()</code> to POST the secret to <code>/api/login</code>. On success, redirects to the dashboard.</p>"},{"location":"architecture/frontend/#dashboard-page","title":"Dashboard Page","text":"<p>Displays all ideas sorted by last updated (descending). Each idea shows its title, status badge, and timestamp. Features:</p> <ul> <li>Pull to refresh via a refresh button</li> <li>Delete on hover (desktop) or long-press interaction</li> <li>Floating action button (bottom right) to navigate to the capture page</li> </ul>"},{"location":"architecture/frontend/#capture-page","title":"Capture Page","text":"<p>A two-field form (title + content textarea) for quick idea entry. The title input is auto-focused on mount. On submit, it calls the <code>POST /api/ideas</code> endpoint and navigates to the new idea's session page.</p>"},{"location":"architecture/frontend/#session-page","title":"Session Page","text":"<p>The most complex page, providing the real-time Claude interaction interface:</p> <ul> <li>Header -- Idea title and status badge</li> <li>Message area -- Scrollable list of chat messages (user and assistant), rendered with Markdown support</li> <li>Streaming buffer -- Displays the currently streaming response as it arrives</li> <li>Tool activity -- Collapsible list of tool calls (Read, Grep, Glob, etc.) with their inputs and results</li> <li>Input bar -- Text input with Send (chat) and Build (hammer icon) buttons; switches to a Cancel button while Claude is streaming</li> </ul> <p>Messages from Claude are rendered with <code>react-markdown</code> + <code>remark-gfm</code> for tables and task lists, and <code>react-syntax-highlighter</code> with the One Dark theme for code blocks.</p>"},{"location":"architecture/frontend/#state-management","title":"State Management","text":""},{"location":"architecture/frontend/#auth-store-storesauthts","title":"Auth Store (<code>stores/auth.ts</code>)","text":"<p>A zustand store managing authentication state:</p> <pre><code>interface AuthState {\n  authenticated: boolean;\n  checking: boolean;\n  error: string | null;\n  check: () =&gt; Promise&lt;void&gt;;   // GET /api/auth/check\n  login: (secret: string) =&gt; Promise&lt;boolean&gt;;  // POST /api/login\n  logout: () =&gt; Promise&lt;void&gt;;  // POST /api/logout\n}\n</code></pre> <p>The <code>check()</code> action is called on app mount to verify the existing session cookie. The <code>login()</code> action returns a boolean indicating success.</p>"},{"location":"architecture/frontend/#connection-store-storesconnectionts","title":"Connection Store (<code>stores/connection.ts</code>)","text":"<p>A simple zustand store tracking the WebSocket connection status:</p> <pre><code>type ConnectionStatus = 'connecting' | 'connected' | 'disconnected';\n\ninterface ConnectionState {\n  status: ConnectionStatus;\n  setStatus: (status: ConnectionStatus) =&gt; void;\n}\n</code></pre> <p>This drives the <code>ConnectionIndicator</code> component in the layout sidebar/nav, which shows a colored dot:</p> <ul> <li>Green for connected</li> <li>Yellow (pulsing) for connecting</li> <li>Red for disconnected</li> </ul>"},{"location":"architecture/frontend/#hooks","title":"Hooks","text":""},{"location":"architecture/frontend/#usewebsocket","title":"<code>useWebSocket</code>","text":"<p>A custom React hook that manages the WebSocket connection lifecycle:</p> <ul> <li>Auto-connect on mount</li> <li>Auto-reconnect on close with exponential backoff (1s, 2s, 4s, ... up to 30s)</li> <li>Reconnect counter reset on successful connection</li> <li>Stable <code>send()</code> function for dispatching typed <code>WsClientMessage</code> objects</li> <li>Connection status tracking (<code>connecting</code>, <code>connected</code>, <code>disconnected</code>)</li> <li>Clean disconnect on unmount</li> </ul> <pre><code>const { send, status } = useWebSocket({\n  onMessage: (msg: WsServerMessage) =&gt; {\n    // Handle incoming messages\n  },\n});\n</code></pre> <p>The URL is derived from the current page location, automatically using <code>wss:</code> for HTTPS and <code>ws:</code> for HTTP.</p>"},{"location":"architecture/frontend/#useideas-and-useidea","title":"<code>useIdeas</code> and <code>useIdea</code>","text":"<p>Data-fetching hooks for the ideas REST API:</p> <ul> <li><code>useIdeas()</code> -- Fetches the full list of ideas on mount. Returns <code>{ ideas, loading, error, fetchIdeas, createIdea, deleteIdea }</code>.</li> <li><code>useIdea(slug)</code> -- Fetches a single idea by slug. Returns <code>{ idea, loading, refetch }</code>.</li> </ul> <p>Both hooks manage loading and error state internally.</p>"},{"location":"architecture/frontend/#ui-components","title":"UI Components","text":"<p>Catalyst uses shadcn/ui components with Tailwind CSS 4:</p> Component File Description <code>Button</code> <code>components/ui/button.tsx</code> Styled button with variants (default, destructive, ghost, secondary) and sizes (default, sm, lg, icon) <code>Input</code> <code>components/ui/input.tsx</code> Styled text input <code>Textarea</code> <code>components/ui/textarea.tsx</code> Styled textarea <code>Badge</code> <code>components/ui/badge.tsx</code> Status badges with color variants for each <code>IdeaStatus</code> <code>Layout</code> <code>components/Layout.tsx</code> App shell with sidebar (desktop) and bottom nav (mobile) <code>ConnectionIndicator</code> <code>components/ConnectionIndicator.tsx</code> Colored dot showing WebSocket status <code>Toast</code> / <code>ToastContainer</code> <code>components/Toast.tsx</code> Toast notification system"},{"location":"architecture/frontend/#dependencies","title":"Dependencies","text":"<p>Key frontend dependencies:</p> Package Version Purpose <code>react</code> 18.3.1 UI framework <code>react-router-dom</code> 7.1.x Client-side routing <code>zustand</code> 5.0.11 Lightweight state management <code>react-markdown</code> 10.1.0 Markdown rendering for Claude responses <code>remark-gfm</code> 4.0.1 GitHub Flavored Markdown support <code>react-syntax-highlighter</code> 16.1.0 Syntax highlighting in code blocks <code>lucide-react</code> 0.474.x Icon library <code>class-variance-authority</code> 0.7.x Component variant system (used by shadcn/ui) <code>clsx</code> + <code>tailwind-merge</code> Latest Tailwind class merging utilities"},{"location":"deployment/","title":"Deployment Overview","text":"<p>Catalyst can be deployed in several ways, from a simple Docker container to a full Kubernetes deployment with Helm. This section covers all options.</p>"},{"location":"deployment/#deployment-options","title":"Deployment Options","text":"Method Best For Complexity Docker Compose Quick single-machine deployment Low Kubernetes + Helm Production deployment on a local cluster Medium Local (no container) Development only Lowest <p>All deployment methods require SSH access to a dev-VM where Claude Code is installed. The container/pod does not run Claude Code itself -- it connects to the dev-VM over SSH.</p>"},{"location":"deployment/#container-image","title":"Container Image","text":"<p>Catalyst uses a multi-stage Dockerfile based on <code>oven/bun</code>:</p> <ol> <li>deps -- Installs all workspace dependencies with <code>bun install --frozen-lockfile</code>.</li> <li>build -- Copies source code and runs <code>bun run --filter '*' build</code> (TypeScript compilation + Vite build).</li> <li>runtime -- Slim image with only production artifacts: backend dist, shared source, frontend dist, and runtime dependencies.</li> </ol> <p>The final image exposes port <code>3001</code> and runs <code>bun packages/backend/dist/index.js</code>.</p>"},{"location":"deployment/#cicd","title":"CI/CD","text":"<p>Catalyst's GitHub Actions workflows automate the entire delivery pipeline:</p>"},{"location":"deployment/#ci-ciyaml","title":"CI (<code>ci.yaml</code>)","text":"<p>Runs on every push and pull request to <code>main</code>:</p> <ul> <li>typecheck -- Runs <code>bun run typecheck</code> across all packages.</li> <li>build-frontend -- Builds the frontend and uploads the dist as an artifact.</li> <li>build-backend -- Builds the backend TypeScript.</li> </ul>"},{"location":"deployment/#container-image-containeryaml","title":"Container Image (<code>container.yaml</code>)","text":"<p>Runs on push to <code>main</code> and version tags (<code>v*</code>):</p> <ul> <li>Builds the Docker image using BuildKit with GitHub Actions cache.</li> <li>Pushes to GitHub Container Registry (<code>ghcr.io</code>).</li> <li>Tags: branch name, semver version, semver major.minor, and git SHA.</li> </ul>"},{"location":"deployment/#helm-chart-helmyaml","title":"Helm Chart (<code>helm.yaml</code>)","text":"<p>Runs on push to <code>main</code> (when <code>chart/</code> files change) and version tags:</p> <ul> <li>Lints the Helm chart with <code>helm lint</code>.</li> <li>Packages the chart and pushes it as an OCI artifact to <code>ghcr.io</code>.</li> </ul>"},{"location":"deployment/#environment-requirements","title":"Environment Requirements","text":"<p>Regardless of deployment method, you need:</p> <ul> <li>A dev-VM accessible over SSH from wherever Catalyst runs</li> <li>An SSH private key that Catalyst can use to authenticate</li> <li>The <code>CATALYST_SECRET</code> and <code>COOKIE_SECRET</code> set to strong values</li> <li>DNS or <code>/etc/hosts</code> configured for your chosen hostname (if using ingress)</li> </ul>"},{"location":"deployment/#security-considerations","title":"Security Considerations","text":"<p>Catalyst should only be accessible over a VPN. It provides authenticated access to Claude Code with full tool permissions in build mode, which means it can read and write files, execute commands, and install packages on the dev-VM.</p> <p>Key security measures in place:</p> <ul> <li>Authentication via a shared secret with timing-safe comparison</li> <li>Signed, HTTP-only, secure (in production) cookies with <code>sameSite: strict</code></li> <li>WebSocket authentication on upgrade</li> <li>Kubernetes NetworkPolicy restricting ingress and egress traffic</li> <li>SSH key authentication (no passwords)</li> </ul>"},{"location":"deployment/docker/","title":"Docker Deployment","text":"<p>Catalyst can be run as a single Docker container using Docker Compose. This is the simplest deployment option for a single-machine setup.</p>"},{"location":"deployment/docker/#prerequisites","title":"Prerequisites","text":"<ul> <li>Docker and Docker Compose installed</li> <li>SSH key for the dev-VM accessible on the Docker host</li> <li>The dev-VM reachable from the Docker host</li> </ul>"},{"location":"deployment/docker/#building-the-image","title":"Building the Image","text":"<p>Build the Catalyst image from the project root:</p> <pre><code>docker compose build\n</code></pre> <p>Or build directly with Docker:</p> <pre><code>docker build -t catalyst:latest .\n</code></pre>"},{"location":"deployment/docker/#dockerfile-stages","title":"Dockerfile Stages","text":"<p>The multi-stage Dockerfile optimizes the final image size:</p> <pre><code>### Stage 1: Dependencies\nFROM oven/bun:1 AS deps\nWORKDIR /app\nCOPY package.json bun.lock* ./\nCOPY packages/shared/package.json packages/shared/\nCOPY packages/backend/package.json packages/backend/\nCOPY packages/frontend/package.json packages/frontend/\nRUN bun install --frozen-lockfile || bun install\n\n### Stage 2: Build\nFROM oven/bun:1 AS build\nWORKDIR /app\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY --from=deps /app/packages/*/node_modules ./packages/*/node_modules\nCOPY . .\nRUN bun run --filter '*' build\n\n### Stage 3: Runtime\nFROM oven/bun:1-slim AS runtime\nWORKDIR /app\nENV NODE_ENV=production\n# Copy only what's needed at runtime\nCOPY --from=deps /app/node_modules ./node_modules\nCOPY --from=build /app/packages/backend/dist ./packages/backend/dist\nCOPY --from=build /app/packages/shared/src ./packages/shared/src\nCOPY --from=build /app/packages/frontend/dist ./packages/frontend/dist\nEXPOSE 3001\nCMD [\"bun\", \"packages/backend/dist/index.js\"]\n</code></pre> <p>Key points:</p> <ul> <li>Dependencies are installed in a separate stage and cached.</li> <li>The runtime image uses <code>oven/bun:1-slim</code> for a smaller footprint.</li> <li>Only compiled backend, shared source (imported at runtime), and frontend static files are copied to the runtime image.</li> </ul>"},{"location":"deployment/docker/#running-with-docker-compose","title":"Running with Docker Compose","text":"<p>The project includes a <code>docker-compose.yml</code>:</p> <pre><code>services:\n  catalyst:\n    build: .\n    ports:\n      - \"3001:3001\"\n    environment:\n      - PORT=3001\n      - NODE_ENV=production\n      - CATALYST_SECRET=${CATALYST_SECRET:-dev-secret}\n      - COOKIE_SECRET=${COOKIE_SECRET:-dev-cookie-secret}\n      - SSH_HOST=${SSH_HOST:-host.docker.internal}\n      - SSH_PORT=${SSH_PORT:-22}\n      - SSH_USER=${SSH_USER:-user}\n      - SSH_KEY_PATH=/secrets/ssh/id_ed25519\n      - IDEAS_BASE_PATH=${IDEAS_BASE_PATH:-~/catalyst/ideas}\n    volumes:\n      - ${SSH_KEY_FILE:-~/.ssh/id_ed25519}:/secrets/ssh/id_ed25519:ro\n    extra_hosts:\n      - \"host.docker.internal:host-gateway\"\n</code></pre>"},{"location":"deployment/docker/#configuration","title":"Configuration","text":"<p>Set your secrets and SSH details as environment variables before running:</p> <pre><code>export CATALYST_SECRET=\"$(openssl rand -hex 32)\"\nexport COOKIE_SECRET=\"$(openssl rand -hex 32)\"\nexport SSH_HOST=192.168.56.10\nexport SSH_USER=vagrant\nexport SSH_KEY_FILE=~/.ssh/catalyst_ed25519\n</code></pre>"},{"location":"deployment/docker/#start","title":"Start","text":"<pre><code>docker compose up -d\n</code></pre> <p>Catalyst is now available at <code>http://localhost:3001</code>.</p>"},{"location":"deployment/docker/#stop","title":"Stop","text":"<pre><code>docker compose down\n</code></pre>"},{"location":"deployment/docker/#ssh-connectivity-from-docker","title":"SSH Connectivity from Docker","text":"<p>The container needs to reach the dev-VM over SSH. There are a few scenarios:</p>"},{"location":"deployment/docker/#dev-vm-on-the-docker-host","title":"Dev-VM on the Docker Host","text":"<p>If your dev-VM is on the same machine (e.g., a Vagrant VM with port forwarding), the <code>docker-compose.yml</code> uses <code>host.docker.internal</code> as the default <code>SSH_HOST</code> with the <code>extra_hosts</code> directive:</p> <pre><code>extra_hosts:\n  - \"host.docker.internal:host-gateway\"\n</code></pre> <p>This works on Linux with Docker 20.10+. On macOS and Windows, <code>host.docker.internal</code> resolves automatically.</p>"},{"location":"deployment/docker/#dev-vm-on-the-network","title":"Dev-VM on the Network","text":"<p>If the dev-VM is on a different machine, set <code>SSH_HOST</code> to its IP or hostname:</p> <pre><code>export SSH_HOST=192.168.1.100\n</code></pre>"},{"location":"deployment/docker/#dev-vm-runs-locally-via-vagrant-port-forwarding","title":"Dev-VM Runs Locally via Vagrant Port Forwarding","text":"<p>If Vagrant forwards SSH from the VM to a host port:</p> <pre><code>export SSH_HOST=host.docker.internal\nexport SSH_PORT=2222\n</code></pre>"},{"location":"deployment/docker/#ssh-key-mount","title":"SSH Key Mount","text":"<p>The SSH private key is mounted as a read-only volume into the container at <code>/secrets/ssh/id_ed25519</code>. The <code>SSH_KEY_PATH</code> environment variable points to this location.</p> <p>Warning</p> <p>Ensure the SSH key file on the host has restrictive permissions (<code>chmod 600</code>). Docker will mount it with the same permissions.</p>"},{"location":"deployment/docker/#running-without-compose","title":"Running Without Compose","text":"<p>You can also run the container directly:</p> <pre><code>docker run -d \\\n  --name catalyst \\\n  -p 3001:3001 \\\n  -e CATALYST_SECRET=\"your-secret\" \\\n  -e COOKIE_SECRET=\"your-cookie-secret\" \\\n  -e SSH_HOST=\"192.168.56.10\" \\\n  -e SSH_USER=\"vagrant\" \\\n  -e SSH_KEY_PATH=\"/secrets/ssh/id_ed25519\" \\\n  -e IDEAS_BASE_PATH=\"~/catalyst/ideas\" \\\n  -e NODE_ENV=\"production\" \\\n  -v ~/.ssh/catalyst_ed25519:/secrets/ssh/id_ed25519:ro \\\n  --add-host=host.docker.internal:host-gateway \\\n  catalyst:latest\n</code></pre>"},{"location":"deployment/docker/#health-check","title":"Health Check","text":"<p>Verify the container is running and SSH is connected:</p> <pre><code>curl http://localhost:3001/api/health\n</code></pre> <p>Expected response:</p> <pre><code>{\n  \"status\": \"ok\",\n  \"ssh\": true,\n  \"uptime\": 10.2\n}\n</code></pre> <p>If <code>\"ssh\": false</code>, check that:</p> <ol> <li>The SSH key is correctly mounted (check <code>docker exec catalyst ls -la /secrets/ssh/</code>).</li> <li>The dev-VM is reachable from inside the container (check <code>docker exec catalyst ping -c1 $SSH_HOST</code>).</li> <li>SSH key permissions are correct on the dev-VM's <code>authorized_keys</code>.</li> </ol>"},{"location":"deployment/helm-values/","title":"Helm Values Reference","text":"<p>Complete reference for all configurable values in the Catalyst Helm chart (<code>chart/values.yaml</code>).</p>"},{"location":"deployment/helm-values/#all-values","title":"All Values","text":""},{"location":"deployment/helm-values/#image","title":"Image","text":"Value Type Default Description <code>image.repository</code> string <code>catalyst</code> Container image repository. Set to <code>ghcr.io/your-org/catalyst</code> for GHCR images. <code>image.tag</code> string <code>latest</code> Image tag. Use a specific version (e.g., <code>v1.0.0</code>) or <code>main</code> for the latest build. <code>image.pullPolicy</code> string <code>IfNotPresent</code> Kubernetes image pull policy. Set to <code>Always</code> when using mutable tags like <code>latest</code> or <code>main</code>."},{"location":"deployment/helm-values/#replica","title":"Replica","text":"Value Type Default Description <code>replicaCount</code> integer <code>1</code> Number of pod replicas. Catalyst is designed for single-replica operation since it uses in-memory session storage. Running multiple replicas will cause authentication issues."},{"location":"deployment/helm-values/#service","title":"Service","text":"Value Type Default Description <code>service.type</code> string <code>ClusterIP</code> Kubernetes service type. <code>ClusterIP</code> is appropriate when using an ingress controller. <code>service.port</code> integer <code>80</code> Service port. The ingress routes traffic to this port. <code>containerPort</code> integer <code>3001</code> Port the Catalyst container listens on. Must match the <code>PORT</code> environment variable."},{"location":"deployment/helm-values/#ingress","title":"Ingress","text":"Value Type Default Description <code>ingress.enabled</code> boolean <code>true</code> Whether to create an Ingress resource. <code>ingress.className</code> string <code>nginx</code> Ingress class name. Must match your installed ingress controller. <code>ingress.host</code> string <code>catalyst.local</code> Hostname for the ingress rule. Set to your actual domain or local hostname. <code>ingress.annotations</code> object (see below) Annotations for the ingress resource. The defaults configure nginx for WebSocket support. <p>Default ingress annotations:</p> <pre><code>ingress:\n  annotations:\n    nginx.ingress.kubernetes.io/proxy-read-timeout: \"3600\"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: \"3600\"\n    nginx.ingress.kubernetes.io/proxy-connect-timeout: \"60\"\n    nginx.ingress.kubernetes.io/websocket-services: \"catalyst\"\n    nginx.ingress.kubernetes.io/proxy-http-version: \"1.1\"\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection \"upgrade\";\n</code></pre> <p>Warning</p> <p>Do not remove the WebSocket annotations. Without them, real-time streaming will not work. The long proxy timeouts (3600s) are necessary because Claude sessions can run for extended periods.</p>"},{"location":"deployment/helm-values/#ssh","title":"SSH","text":"Value Type Default Description <code>ssh.host</code> string <code>dev-vm.local</code> Hostname or IP of the dev-VM. Written to the ConfigMap as <code>SSH_HOST</code>. <code>ssh.port</code> string <code>\"22\"</code> SSH port on the dev-VM. Written to the ConfigMap as <code>SSH_PORT</code>. <code>ssh.user</code> string <code>user</code> SSH username. Written to the ConfigMap as <code>SSH_USER</code>. <code>ssh.ideasBasePath</code> string <code>~/catalyst/ideas</code> Base path on the dev-VM for idea storage. Written to the ConfigMap as <code>IDEAS_BASE_PATH</code>. <code>ssh.keyPath</code> string <code>/secrets/ssh/id_ed25519</code> Path inside the container where the SSH key is mounted. Set as the <code>SSH_KEY_PATH</code> env var. <code>ssh.existingKeySecret</code> string <code>catalyst-ssh-key</code> Name of the Kubernetes Secret containing the SSH private key. The key must be stored under the key name <code>id_ed25519</code>."},{"location":"deployment/helm-values/#secrets","title":"Secrets","text":"Value Type Default Description <code>secrets.useExisting</code> boolean <code>true</code> When <code>true</code>, the chart does not create a Secret resource. You must pre-create a secret named <code>catalyst-secrets</code> with keys <code>CATALYST_SECRET</code> and <code>COOKIE_SECRET</code>. <code>secrets.catalystSecret</code> string <code>CHANGE_ME</code> The login secret. Only used when <code>secrets.useExisting</code> is <code>false</code>. <code>secrets.cookieSecret</code> string <code>CHANGE_ME</code> The cookie signing secret. Only used when <code>secrets.useExisting</code> is <code>false</code>. <p>Tip</p> <p>It is strongly recommended to set <code>secrets.useExisting: true</code> and create secrets manually with <code>kubectl</code>. This avoids storing secrets in values files or Helm release history.</p>"},{"location":"deployment/helm-values/#resources","title":"Resources","text":"Value Type Default Description <code>resources.requests.memory</code> string <code>128Mi</code> Memory request. Catalyst is lightweight since Claude runs on the dev-VM. <code>resources.requests.cpu</code> string <code>100m</code> CPU request. <code>resources.limits.memory</code> string <code>512Mi</code> Memory limit. <code>resources.limits.cpu</code> string <code>500m</code> CPU limit."},{"location":"deployment/helm-values/#network-policy","title":"Network Policy","text":"Value Type Default Description <code>networkPolicy.enabled</code> boolean <code>true</code> Whether to create a NetworkPolicy restricting pod traffic. <code>networkPolicy.ingressNamespace</code> string <code>ingress-nginx</code> Namespace of the ingress controller. Only pods in this namespace can send traffic to Catalyst. <code>networkPolicy.sshEgressCidr</code> string <code>0.0.0.0/0</code> CIDR block allowed for SSH egress. Narrow this to your dev-VM's subnet for tighter security."},{"location":"deployment/helm-values/#health-probes","title":"Health Probes","text":"Value Type Default Description <code>livenessProbe.httpGet.path</code> string <code>/api/health</code> Health check endpoint. <code>livenessProbe.httpGet.port</code> integer <code>3001</code> Port for the health check. <code>livenessProbe.initialDelaySeconds</code> integer <code>10</code> Seconds to wait before the first liveness check. <code>livenessProbe.periodSeconds</code> integer <code>30</code> Seconds between liveness checks. <code>readinessProbe.httpGet.path</code> string <code>/api/health</code> Health check endpoint. <code>readinessProbe.httpGet.port</code> integer <code>3001</code> Port for the health check. <code>readinessProbe.initialDelaySeconds</code> integer <code>5</code> Seconds to wait before the first readiness check. <code>readinessProbe.periodSeconds</code> integer <code>10</code> Seconds between readiness checks."},{"location":"deployment/helm-values/#example-minimal-production-override","title":"Example: Minimal Production Override","text":"<pre><code># values-prod.yaml\nimage:\n  repository: ghcr.io/myorg/catalyst\n  tag: v1.0.0\n  pullPolicy: IfNotPresent\n\ningress:\n  host: catalyst.home.lan\n\nssh:\n  host: \"192.168.1.50\"\n  user: \"dev\"\n  ideasBasePath: \"~/projects/catalyst-ideas\"\n\nsecrets:\n  useExisting: true\n\nnetworkPolicy:\n  sshEgressCidr: \"192.168.1.50/32\"\n</code></pre>"},{"location":"deployment/helm-values/#example-let-chart-manage-secrets","title":"Example: Let Chart Manage Secrets","text":"<pre><code># values-dev.yaml (NOT recommended for production)\nsecrets:\n  useExisting: false\n  catalystSecret: \"my-dev-secret\"\n  cookieSecret: \"my-dev-cookie-secret\"\n</code></pre> <p>Danger</p> <p>Secrets in values files are stored in Helm release history. Use <code>secrets.useExisting: true</code> in production and create secrets with <code>kubectl</code> instead.</p>"},{"location":"deployment/kubernetes/","title":"Kubernetes Deployment","text":"<p>Catalyst includes a Helm chart for deployment to a Kubernetes cluster. This is the recommended deployment method for production use on a local cluster behind a VPN.</p>"},{"location":"deployment/kubernetes/#prerequisites","title":"Prerequisites","text":"<ul> <li>A Kubernetes cluster with <code>kubectl</code> configured</li> <li>An nginx ingress controller installed (e.g., <code>ingress-nginx</code>)</li> <li>Helm 3 installed</li> <li>The Catalyst container image available (either built locally or pulled from GHCR)</li> <li>DNS or <code>/etc/hosts</code> configured to resolve your chosen hostname to the ingress controller</li> </ul>"},{"location":"deployment/kubernetes/#architecture-in-kubernetes","title":"Architecture in Kubernetes","text":"<pre><code>graph TB\n    subgraph \"Kubernetes Cluster\"\n        A[Ingress&lt;br/&gt;nginx] --&gt; B[Service&lt;br/&gt;ClusterIP:80]\n        B --&gt; C[Catalyst Pod&lt;br/&gt;:3001]\n        D[ConfigMap] --&gt; C\n        E[Secret&lt;br/&gt;catalyst-secrets] --&gt; C\n        F[Secret&lt;br/&gt;catalyst-ssh-key] --&gt; C\n        G[NetworkPolicy] -.-&gt;|restricts| C\n    end\n    C --&gt;|SSH| H[Dev-VM]</code></pre> <p>The Helm chart creates:</p> <ul> <li>Namespace (uses the release namespace)</li> <li>Deployment with one replica</li> <li>Service (ClusterIP on port 80, targeting port 3001)</li> <li>Ingress with nginx annotations for WebSocket support</li> <li>ConfigMap with SSH connection settings</li> <li>Secret for <code>CATALYST_SECRET</code> and <code>COOKIE_SECRET</code> (optional, can use pre-existing)</li> <li>NetworkPolicy restricting ingress to the nginx namespace and egress to DNS + SSH</li> </ul>"},{"location":"deployment/kubernetes/#quick-start","title":"Quick Start","text":""},{"location":"deployment/kubernetes/#1-create-the-namespace","title":"1. Create the Namespace","text":"<pre><code>kubectl create namespace catalyst\n</code></pre>"},{"location":"deployment/kubernetes/#2-create-secrets","title":"2. Create Secrets","text":"<p>Catalyst expects two secrets. It is recommended to create them manually rather than having the chart manage them:</p> <pre><code># Application secrets\nkubectl create secret generic catalyst-secrets \\\n  --from-literal=CATALYST_SECRET=\"$(openssl rand -hex 32)\" \\\n  --from-literal=COOKIE_SECRET=\"$(openssl rand -hex 32)\" \\\n  -n catalyst\n\n# SSH private key\nkubectl create secret generic catalyst-ssh-key \\\n  --from-file=id_ed25519=~/.ssh/catalyst_ed25519 \\\n  -n catalyst\n</code></pre>"},{"location":"deployment/kubernetes/#3-create-a-values-override","title":"3. Create a Values Override","text":"<p>Create a <code>values-prod.yaml</code> file:</p> <pre><code>image:\n  repository: ghcr.io/your-org/catalyst\n  tag: main\n  pullPolicy: Always\n\ningress:\n  enabled: true\n  className: nginx\n  host: catalyst.yourdomain.com\n\nssh:\n  host: \"192.168.1.100\"\n  port: \"22\"\n  user: \"vagrant\"\n  ideasBasePath: \"~/catalyst/ideas\"\n  existingKeySecret: \"catalyst-ssh-key\"\n\nsecrets:\n  useExisting: true\n</code></pre>"},{"location":"deployment/kubernetes/#4-install-the-chart","title":"4. Install the Chart","text":"From local chartFrom GHCR OCI registry <pre><code>helm install catalyst ./chart \\\n  -f values-prod.yaml \\\n  -n catalyst\n</code></pre> <pre><code>helm install catalyst oci://ghcr.io/your-org/charts/catalyst \\\n  -f values-prod.yaml \\\n  -n catalyst\n</code></pre>"},{"location":"deployment/kubernetes/#5-verify-the-deployment","title":"5. Verify the Deployment","text":"<pre><code># Check pod status\nkubectl get pods -n catalyst\n\n# Check the deployment rollout\nkubectl rollout status deployment/catalyst -n catalyst\n\n# View the Helm notes\nhelm get notes catalyst -n catalyst\n\n# Test the health endpoint\nkubectl port-forward svc/catalyst 8080:80 -n catalyst\ncurl http://localhost:8080/api/health\n</code></pre>"},{"location":"deployment/kubernetes/#upgrading","title":"Upgrading","text":"<p>When a new image is available:</p> <pre><code>helm upgrade catalyst ./chart \\\n  -f values-prod.yaml \\\n  -n catalyst \\\n  --set image.tag=v1.2.3\n</code></pre> <p>Or if using the OCI registry:</p> <pre><code>helm upgrade catalyst oci://ghcr.io/your-org/charts/catalyst \\\n  -f values-prod.yaml \\\n  -n catalyst\n</code></pre>"},{"location":"deployment/kubernetes/#ingress-configuration","title":"Ingress Configuration","text":"<p>The chart configures the nginx ingress with annotations for WebSocket support. These are critical for real-time Claude streaming:</p> <pre><code>ingress:\n  annotations:\n    nginx.ingress.kubernetes.io/proxy-read-timeout: \"3600\"\n    nginx.ingress.kubernetes.io/proxy-send-timeout: \"3600\"\n    nginx.ingress.kubernetes.io/proxy-connect-timeout: \"60\"\n    nginx.ingress.kubernetes.io/websocket-services: \"catalyst\"\n    nginx.ingress.kubernetes.io/proxy-http-version: \"1.1\"\n    nginx.ingress.kubernetes.io/configuration-snippet: |\n      proxy_set_header Upgrade $http_upgrade;\n      proxy_set_header Connection \"upgrade\";\n</code></pre> <p>The long timeouts (3600 seconds = 1 hour) are necessary because Claude sessions can run for extended periods during builds.</p>"},{"location":"deployment/kubernetes/#network-policy","title":"Network Policy","text":"<p>When <code>networkPolicy.enabled</code> is <code>true</code> (the default), the chart creates a <code>NetworkPolicy</code> that:</p> <p>Allows ingress from:</p> <ul> <li>The ingress-nginx namespace only (configurable via <code>networkPolicy.ingressNamespace</code>)</li> </ul> <p>Allows egress to:</p> <ul> <li>DNS (port 53, UDP and TCP) in any namespace</li> <li>SSH (configurable port) to the dev-VM (configurable CIDR via <code>networkPolicy.sshEgressCidr</code>)</li> </ul> <p>This prevents the Catalyst pod from making any other outbound connections.</p> <pre><code>networkPolicy:\n  enabled: true\n  ingressNamespace: ingress-nginx\n  sshEgressCidr: \"192.168.1.0/24\"  # Restrict to your dev-VM's subnet\n</code></pre> <p>Tip</p> <p>Set <code>sshEgressCidr</code> to the narrowest CIDR that covers your dev-VM's IP. The default <code>0.0.0.0/0</code> is permissive and should be tightened in production.</p>"},{"location":"deployment/kubernetes/#health-probes","title":"Health Probes","text":"<p>The chart configures both liveness and readiness probes against the <code>/api/health</code> endpoint:</p> <pre><code>livenessProbe:\n  httpGet:\n    path: /api/health\n    port: 3001\n  initialDelaySeconds: 10\n  periodSeconds: 30\n\nreadinessProbe:\n  httpGet:\n    path: /api/health\n    port: 3001\n  initialDelaySeconds: 5\n  periodSeconds: 10\n</code></pre> <p>The health endpoint checks SSH connectivity. If the dev-VM becomes unreachable, the readiness probe will fail and Kubernetes will stop routing traffic to the pod. The liveness probe will eventually restart the pod if SSH remains unavailable.</p>"},{"location":"deployment/kubernetes/#resource-limits","title":"Resource Limits","text":"<p>Default resource requests and limits:</p> <pre><code>resources:\n  requests:\n    memory: \"128Mi\"\n    cpu: \"100m\"\n  limits:\n    memory: \"512Mi\"\n    cpu: \"500m\"\n</code></pre> <p>Catalyst is lightweight since Claude Code runs on the dev-VM, not in the pod. The pod primarily proxies WebSocket traffic and manages SSH connections. These defaults are suitable for most setups.</p>"},{"location":"deployment/kubernetes/#troubleshooting","title":"Troubleshooting","text":""},{"location":"deployment/kubernetes/#pod-is-in-crashloopbackoff","title":"Pod is in CrashLoopBackOff","text":"<p>Check the logs:</p> <pre><code>kubectl logs -n catalyst deployment/catalyst\n</code></pre> <p>Common causes:</p> <ul> <li>Missing secrets (<code>catalyst-secrets</code> or <code>catalyst-ssh-key</code> not created)</li> <li>Invalid SSH key format</li> </ul>"},{"location":"deployment/kubernetes/#pod-is-running-but-not-ready","title":"Pod is running but not ready","text":"<p>The readiness probe is failing, likely because SSH connectivity is down:</p> <pre><code>kubectl exec -n catalyst deployment/catalyst -- curl -s localhost:3001/api/health\n</code></pre> <p>Check that the dev-VM is reachable from the pod:</p> <pre><code>kubectl exec -n catalyst deployment/catalyst -- nc -zv &lt;SSH_HOST&gt; &lt;SSH_PORT&gt;\n</code></pre>"},{"location":"deployment/kubernetes/#websocket-connection-fails","title":"WebSocket connection fails","text":"<p>Verify the ingress annotations are applied:</p> <pre><code>kubectl get ingress -n catalyst catalyst -o yaml\n</code></pre> <p>Check that the nginx ingress controller supports WebSocket (it does by default, but the annotations must be present).</p>"},{"location":"deployment/kubernetes/#tls","title":"TLS","text":"<p>The chart does not configure TLS by default. If your cluster uses cert-manager, you can add TLS configuration to the ingress annotations in your values override. Since Catalyst should be behind a VPN, TLS may not be strictly necessary, but it is still recommended.</p>"},{"location":"development/","title":"Development Guide","text":"<p>This section covers everything you need to work on Catalyst itself: the project structure, local development workflow, and contribution guidelines.</p>"},{"location":"development/#prerequisites-for-development","title":"Prerequisites for Development","text":"<ul> <li>Bun 1.x -- Package manager and runtime</li> <li>A code editor with TypeScript support (VS Code recommended)</li> <li>SSH access to a dev-VM with Claude Code installed (for testing Claude features)</li> <li>Git for version control</li> </ul>"},{"location":"development/#quick-reference","title":"Quick Reference","text":"Command Description <code>bun install</code> Install all dependencies for all packages <code>bun run dev</code> Start backend + frontend in development mode <code>bun run build</code> Production build of all packages <code>bun run typecheck</code> TypeScript type checking across all packages"},{"location":"development/#development-workflow","title":"Development Workflow","text":"<ol> <li>Clone the repo and run <code>bun install</code>.</li> <li>Set up your SSH environment (see Configuration).</li> <li>Run <code>bun run dev</code> to start both the backend (port 3001) and frontend (port 3000).</li> <li>Open <code>http://localhost:3000</code> and log in with <code>dev-secret</code>.</li> <li>Make changes -- the backend restarts automatically via <code>bun --watch</code>, and the frontend has Vite HMR.</li> <li>Run <code>bun run typecheck</code> before committing to catch type errors.</li> </ol>"},{"location":"development/#sections","title":"Sections","text":"<ul> <li>Project Structure -- Understand the monorepo layout and what each package does.</li> <li>Local Development -- Detailed guide for running and debugging locally.</li> <li>Contributing -- How to contribute, PR workflow, and CI checks.</li> </ul>"},{"location":"development/contributing/","title":"Contributing","text":"<p>Guidelines for contributing to Catalyst.</p>"},{"location":"development/contributing/#development-setup","title":"Development Setup","text":"<ol> <li>Fork and clone the repository.</li> <li>Run <code>bun install</code> to install all dependencies.</li> <li> <p>Create a feature branch from <code>main</code>:</p> <pre><code>git checkout -b feature/my-feature\n</code></pre> </li> <li> <p>Make your changes.</p> </li> <li> <p>Run checks locally before pushing:</p> <pre><code>bun run typecheck\nbun run build\n</code></pre> </li> <li> <p>Push and open a pull request.</p> </li> </ol>"},{"location":"development/contributing/#pull-request-workflow","title":"Pull Request Workflow","text":""},{"location":"development/contributing/#branch-naming","title":"Branch Naming","text":"<p>Use descriptive branch names with a prefix:</p> <ul> <li><code>feature/</code> -- New features</li> <li><code>fix/</code> -- Bug fixes</li> <li><code>refactor/</code> -- Code improvements without behavior changes</li> <li><code>docs/</code> -- Documentation updates</li> <li><code>chore/</code> -- Maintenance tasks (dependency updates, CI changes)</li> </ul>"},{"location":"development/contributing/#pr-requirements","title":"PR Requirements","text":"<p>Before a PR can be merged:</p> <ol> <li>TypeScript type checking passes -- The CI runs <code>bun run typecheck</code> across all packages.</li> <li>Frontend builds successfully -- The CI runs a full Vite production build.</li> <li>Backend builds successfully -- The CI runs <code>tsc</code> to compile the backend.</li> <li>PR description -- Describe what changed and why. Include screenshots for UI changes.</li> </ol>"},{"location":"development/contributing/#review-process","title":"Review Process","text":"<ul> <li>PRs are reviewed for correctness, code style, and alignment with the project's architecture.</li> <li>Keep PRs focused. One logical change per PR is easier to review than a large omnibus PR.</li> <li>If a PR touches the shared types package, pay extra attention to backward compatibility with the WebSocket protocol.</li> </ul>"},{"location":"development/contributing/#ci-checks","title":"CI Checks","text":"<p>Three CI workflows run on every PR to <code>main</code>:</p>"},{"location":"development/contributing/#ciyaml","title":"<code>ci.yaml</code>","text":"Job Command Description <code>typecheck</code> <code>bun run typecheck</code> Type-checks all packages <code>build-frontend</code> <code>bun run --filter '@catalyst/frontend' build</code> Full Vite production build <code>build-backend</code> <code>bun run --filter '@catalyst/backend' build</code> TypeScript compilation"},{"location":"development/contributing/#containeryaml-push-to-main-only","title":"<code>container.yaml</code> (push to <code>main</code> only)","text":"<p>Builds the Docker image and pushes to GHCR. This does not run on PRs.</p>"},{"location":"development/contributing/#helmyaml-push-to-main-when-chart-changes","title":"<code>helm.yaml</code> (push to <code>main</code> when <code>chart/</code> changes)","text":"<p>Lints and publishes the Helm chart to GHCR OCI.</p>"},{"location":"development/contributing/#code-style","title":"Code Style","text":""},{"location":"development/contributing/#typescript","title":"TypeScript","text":"<ul> <li>Strict mode is enabled. All code must pass strict type checking.</li> <li> <p>Use <code>satisfies</code> for type-checking API responses:</p> <pre><code>res.json({ ok: true, data: ideas } satisfies ApiResponse&lt;IdeaMeta[]&gt;);\n</code></pre> </li> <li> <p>Prefer <code>interface</code> over <code>type</code> for object shapes.</p> </li> <li>Use named exports, not default exports.</li> </ul>"},{"location":"development/contributing/#react","title":"React","text":"<ul> <li>Use function components with hooks.</li> <li>State management with zustand stores for global state, <code>useState</code> for local state.</li> <li>Custom hooks for reusable logic (e.g., <code>useWebSocket</code>, <code>useIdeas</code>).</li> <li>Use <code>@/</code> path alias for imports within the frontend package.</li> </ul>"},{"location":"development/contributing/#css","title":"CSS","text":"<ul> <li>Use Tailwind CSS utility classes. Avoid custom CSS where possible.</li> <li>Use shadcn/ui components as the base for UI elements.</li> <li>Follow the existing dark theme (slate scheme).</li> </ul>"},{"location":"development/contributing/#file-organization","title":"File Organization","text":"<ul> <li>One component per file.</li> <li>Group by feature/concern: pages in <code>pages/</code>, hooks in <code>hooks/</code>, stores in <code>stores/</code>, reusable UI in <code>components/ui/</code>.</li> <li>Keep the shared package as types only -- no runtime code.</li> </ul>"},{"location":"development/contributing/#making-changes-to-the-websocket-protocol","title":"Making Changes to the WebSocket Protocol","text":"<p>The WebSocket protocol is defined in <code>packages/shared/src/index.ts</code>. If you need to add or modify message types:</p> <ol> <li>Update the type definitions in <code>@catalyst/shared</code>.</li> <li>Update the backend WebSocket handler (<code>packages/backend/src/ws.ts</code>).</li> <li>Update the frontend message handler (typically in <code>pages/Session.tsx</code>).</li> <li>Document the changes in <code>docs/api/websocket.md</code>.</li> </ol> <p>Since the shared package is imported from source, there is no build step needed for type changes to propagate. However, ensure both the backend and frontend handle the new message types.</p>"},{"location":"development/contributing/#making-changes-to-the-rest-api","title":"Making Changes to the REST API","text":"<ol> <li>Update or add route handlers in <code>packages/backend/src/routes/</code>.</li> <li>Add any new response types to <code>@catalyst/shared</code>.</li> <li>Update frontend hooks or add new ones in <code>packages/frontend/src/hooks/</code>.</li> <li>Document the changes in <code>docs/api/rest.md</code>.</li> </ol>"},{"location":"development/contributing/#making-changes-to-the-helm-chart","title":"Making Changes to the Helm Chart","text":"<ol> <li>Modify templates in <code>chart/templates/</code> or values in <code>chart/values.yaml</code>.</li> <li>Run <code>helm lint chart/</code> locally to check for errors.</li> <li>Update <code>docs/deployment/helm-values.md</code> if you add or change values.</li> <li>Bump the chart version in <code>chart/Chart.yaml</code> for significant changes.</li> </ol>"},{"location":"development/contributing/#versioning","title":"Versioning","text":"<p>Catalyst follows Semantic Versioning:</p> <ul> <li>Patch (<code>v1.0.x</code>) -- Bug fixes, dependency updates</li> <li>Minor (<code>v1.x.0</code>) -- New features, non-breaking changes</li> <li>Major (<code>vx.0.0</code>) -- Breaking changes to the API, WebSocket protocol, or Helm chart values</li> </ul> <p>Version tags (<code>v*</code>) trigger the container image and Helm chart CI workflows.</p>"},{"location":"development/local-dev/","title":"Local Development","text":"<p>This guide covers the day-to-day development workflow for working on Catalyst locally.</p>"},{"location":"development/local-dev/#starting-the-dev-servers","title":"Starting the Dev Servers","text":"<p>From the project root:</p> <pre><code>bun run dev\n</code></pre> <p>This starts both services concurrently:</p> Service Port Command Features Backend 3001 <code>bun --watch src/index.ts</code> Auto-restart on file changes Frontend 3000 <code>vite --port 3000</code> Hot Module Replacement (HMR) <p>Open <code>http://localhost:3000</code> in your browser. The Vite dev server proxies all <code>/api/*</code> and <code>/ws</code> requests to the backend on port 3001, so everything works from a single URL.</p>"},{"location":"development/local-dev/#how-the-proxy-works","title":"How the Proxy Works","text":"<p>The Vite dev server is configured in <code>packages/frontend/vite.config.ts</code> to proxy requests:</p> <pre><code>server: {\n  proxy: {\n    '/api': {\n      target: 'http://localhost:3001',\n      changeOrigin: true,\n    },\n    '/ws': {\n      target: 'ws://localhost:3001',\n      ws: true,\n    },\n  },\n}\n</code></pre> <p>This means:</p> <ul> <li><code>http://localhost:3000/api/health</code> proxies to <code>http://localhost:3001/api/health</code></li> <li><code>ws://localhost:3000/ws</code> proxies to <code>ws://localhost:3001/ws</code></li> <li>All other requests are served by Vite (your React app)</li> </ul>"},{"location":"development/local-dev/#backend-development","title":"Backend Development","text":"<p>The backend runs with <code>bun --watch</code>, which automatically restarts the process when any TypeScript file in the backend package changes. There is no compilation step during development -- Bun runs TypeScript directly.</p>"},{"location":"development/local-dev/#testing-ssh-connectivity","title":"Testing SSH Connectivity","text":"<p>If you do not have a dev-VM available, you can test the backend partially by pointing SSH at your local machine:</p> <pre><code>export SSH_HOST=localhost\nexport SSH_USER=$USER\nexport SSH_KEY_PATH=~/.ssh/id_ed25519\n</code></pre> <p>This requires:</p> <ul> <li>An SSH server running on your machine</li> <li>Your SSH key in <code>~/.ssh/authorized_keys</code></li> <li>Claude Code installed locally</li> </ul>"},{"location":"development/local-dev/#testing-without-claude-code","title":"Testing Without Claude Code","text":"<p>You can test the REST API, authentication, and WebSocket connection without Claude Code. The health endpoint will report <code>\"ssh\": false</code> if the dev-VM is unreachable, but the app will still function for:</p> <ul> <li>Logging in and out</li> <li>Creating, listing, and deleting ideas</li> <li>WebSocket connection (messages will return errors when you try to chat or build)</li> </ul>"},{"location":"development/local-dev/#debugging","title":"Debugging","text":"<p>Since Bun is the runtime, you can use the Bun debugger:</p> <pre><code>cd packages/backend\nbun --inspect --watch src/index.ts\n</code></pre> <p>Then attach your editor's debugger to the Bun debug port.</p> <p>Alternatively, add <code>console.log</code> statements -- Bun's fast restart makes the edit-run-debug cycle very quick.</p>"},{"location":"development/local-dev/#frontend-development","title":"Frontend Development","text":"<p>The frontend uses Vite with React Fast Refresh. Changes to React components are reflected instantly in the browser without a full page reload. CSS changes via Tailwind are also hot-reloaded.</p>"},{"location":"development/local-dev/#path-aliases","title":"Path Aliases","text":"<p>The <code>@/</code> alias maps to <code>packages/frontend/src/</code>:</p> <pre><code>import { Button } from '@/components/ui/button';\nimport { useAuthStore } from '@/stores/auth';\n</code></pre>"},{"location":"development/local-dev/#adding-shadcnui-components","title":"Adding shadcn/ui Components","text":"<p>Catalyst uses shadcn/ui components manually installed (not via the CLI). To add a new component:</p> <ol> <li>Visit the shadcn/ui documentation.</li> <li>Copy the component source code.</li> <li>Create a new file in <code>packages/frontend/src/components/ui/</code>.</li> <li>Adjust imports to use the project's <code>@/lib/utils</code> utility.</li> </ol>"},{"location":"development/local-dev/#tailwind-css-4","title":"Tailwind CSS 4","text":"<p>The project uses Tailwind CSS 4 with the <code>@tailwindcss/vite</code> plugin. Configuration is done via CSS rather than a <code>tailwind.config.js</code> file. The theme is defined in <code>src/index.css</code>.</p>"},{"location":"development/local-dev/#running-individual-packages","title":"Running Individual Packages","text":"<p>You can run scripts for specific packages using Bun's filter:</p> <pre><code># Start only the backend\nbun run --filter '@catalyst/backend' dev\n\n# Build only the frontend\nbun run --filter '@catalyst/frontend' build\n\n# Type-check only shared types\nbun run --filter '@catalyst/shared' typecheck\n</code></pre>"},{"location":"development/local-dev/#type-checking","title":"Type Checking","text":"<p>Run type checking across all packages:</p> <pre><code>bun run typecheck\n</code></pre> <p>This runs <code>tsc --noEmit</code> in each package. The shared package is checked first since the backend and frontend depend on it.</p> <p>During development, you can run type checking in watch mode for a specific package:</p> <pre><code>cd packages/shared\nbun run dev    # tsc --watch --noEmit\n</code></pre>"},{"location":"development/local-dev/#production-build-locally","title":"Production Build Locally","text":"<p>To test the production build locally:</p> <pre><code># Build everything\nbun run build\n\n# Start the production server\nNODE_ENV=production bun packages/backend/dist/index.js\n</code></pre> <p>In production mode, the backend serves the frontend's static files from <code>packages/frontend/dist/</code>. Visit <code>http://localhost:3001</code> (not port 3000).</p>"},{"location":"development/local-dev/#docker-build-locally","title":"Docker Build Locally","text":"<p>To test the Docker image:</p> <pre><code>docker compose build\ndocker compose up\n</code></pre> <p>The container runs in production mode on port 3001. See Docker Deployment for details.</p>"},{"location":"development/local-dev/#common-issues","title":"Common Issues","text":""},{"location":"development/local-dev/#missing-env-var-ssh_key","title":"\"Missing env var: SSH_KEY\"","text":"<p>The backend cannot find an SSH key. Either:</p> <ul> <li>Set <code>SSH_KEY_PATH</code> to your SSH private key file</li> <li>Set <code>SSH_KEY</code> to the key contents directly</li> <li>Create a key file at the default path <code>/secrets/ssh/id_ed25519</code></li> </ul>"},{"location":"development/local-dev/#frontend-shows-disconnected","title":"Frontend shows \"Disconnected\"","text":"<p>The WebSocket connection to the backend failed. Check that:</p> <ul> <li>The backend is running on port 3001</li> <li>The Vite proxy configuration is correct</li> <li>You are accessing the app via <code>localhost:3000</code> (not 3001 during development)</li> </ul>"},{"location":"development/local-dev/#ssh-connection-pool-exhausted","title":"\"SSH connection pool exhausted\"","text":"<p>All SSH connections are busy and the 10-second timeout was reached. This happens when multiple concurrent Claude sessions exceed <code>MAX_SSH_CONNECTIONS</code> (default 3). Increase the limit or wait for a session to complete.</p>"},{"location":"development/local-dev/#changes-not-reflected","title":"Changes not reflected","text":"<ul> <li>Backend: Check that <code>bun --watch</code> is running. It should automatically restart on file changes.</li> <li>Frontend: Vite HMR should apply changes instantly. If not, try a hard refresh (<code>Ctrl+Shift+R</code>).</li> <li>Shared types: Changes to <code>@catalyst/shared</code> are picked up automatically since it is imported from source. However, your editor's TypeScript server may need a restart to recognize new types.</li> </ul>"},{"location":"development/project-structure/","title":"Project Structure","text":"<p>Catalyst is organized as a Bun workspace monorepo. This page explains the directory layout and the role of each package and file.</p>"},{"location":"development/project-structure/#root-layout","title":"Root Layout","text":"<pre><code>catalyst/\n  .github/\n    workflows/\n      ci.yaml              # Typecheck and build CI\n      container.yaml        # Docker image build and push to GHCR\n      helm.yaml             # Helm chart lint, package, and push to GHCR\n  chart/\n    Chart.yaml              # Helm chart metadata\n    values.yaml             # Default Helm values\n    templates/\n      _helpers.tpl          # Helm template helpers (names, labels)\n      configmap.yaml        # SSH connection config\n      deployment.yaml       # Catalyst pod deployment\n      ingress.yaml          # Nginx ingress with WebSocket support\n      namespace.yaml        # Namespace resource\n      networkpolicy.yaml    # Ingress/egress restrictions\n      NOTES.txt             # Post-install instructions\n      secret.yaml           # Optional chart-managed secrets\n      service.yaml          # ClusterIP service\n  packages/\n    shared/                 # Shared TypeScript types\n    backend/                # Express server\n    frontend/               # React SPA\n  docker-compose.yml        # Single-machine Docker deployment\n  Dockerfile                # Multi-stage container build\n  package.json              # Root workspace configuration\n  tsconfig.base.json        # Shared TypeScript compiler options\n  bun.lock                  # Bun lockfile\n  .gitignore\n</code></pre>"},{"location":"development/project-structure/#root-packagejson","title":"Root <code>package.json</code>","text":"<p>The root <code>package.json</code> defines the workspace and top-level scripts:</p> <pre><code>{\n  \"name\": \"catalyst\",\n  \"private\": true,\n  \"workspaces\": [\"packages/*\"],\n  \"scripts\": {\n    \"dev\": \"bun run --filter '*' dev\",\n    \"build\": \"bun run --filter '*' build\",\n    \"typecheck\": \"bun run --filter '*' typecheck\"\n  }\n}\n</code></pre> <p>The <code>--filter '*'</code> flag runs the script in all workspace packages that define it. Bun handles dependency ordering automatically.</p>"},{"location":"development/project-structure/#tsconfigbasejson","title":"<code>tsconfig.base.json</code>","text":"<p>Shared TypeScript configuration extended by all packages:</p> <pre><code>{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"bundler\",\n    \"esModuleInterop\": true,\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"resolveJsonModule\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  }\n}\n</code></pre> <p>Key choices:</p> <ul> <li>ES2022 target -- Allows modern syntax (top-level await, etc.)</li> <li>Bundler module resolution -- Works with both Vite (frontend) and Bun (backend)</li> <li>Strict mode -- Full TypeScript strictness enabled</li> </ul>"},{"location":"development/project-structure/#catalystshared","title":"<code>@catalyst/shared</code>","text":"<pre><code>packages/shared/\n  src/\n    index.ts               # All type definitions\n  package.json\n  tsconfig.json\n</code></pre> <p>The shared package contains only TypeScript type definitions -- no runtime code. It exports:</p> <ul> <li>Idea types: <code>IdeaStatus</code>, <code>IdeaMeta</code>, <code>Idea</code></li> <li>Claude stream types: <code>ClaudeSystemInit</code>, <code>ClaudeAssistantText</code>, <code>ClaudeToolUse</code>, <code>ClaudeToolResult</code>, <code>ClaudeResult</code>, <code>ClaudeStreamMessage</code></li> <li>WebSocket protocol: <code>WsChatMessage</code>, <code>WsBuildMessage</code>, <code>WsCancelMessage</code>, <code>WsClientMessage</code>, <code>WsClaudeSystemMessage</code>, <code>WsClaudeTextMessage</code>, <code>WsClaudeToolUseMessage</code>, <code>WsClaudeToolResultMessage</code>, <code>WsClaudeResultMessage</code>, <code>WsClaudeErrorMessage</code>, <code>WsServerMessage</code></li> <li>API types: <code>ApiResponse&lt;T&gt;</code>, <code>AuthCheckResponse</code>, <code>HealthResponse</code></li> </ul> <p>The package is referenced as <code>@catalyst/shared</code> with <code>\"workspace:*\"</code> in the dependent packages. Its <code>main</code> and <code>types</code> fields both point to <code>./src/index.ts</code>, so both the backend and frontend import types directly from source.</p> <p>Scripts:</p> <ul> <li><code>dev</code> -- <code>tsc --watch --noEmit</code> (type checking in watch mode)</li> <li><code>typecheck</code> -- <code>tsc --noEmit</code></li> </ul>"},{"location":"development/project-structure/#catalystbackend","title":"<code>@catalyst/backend</code>","text":"<pre><code>packages/backend/\n  src/\n    index.ts               # Express app entry point, server startup\n    config.ts              # Environment variable loading\n    auth.ts                # Login/logout routes, cookie auth, token store\n    ws.ts                  # WebSocket server setup and message routing\n    routes/\n      ideas.ts             # REST API for ideas CRUD\n    services/\n      ssh.ts               # SSH connection pooling and command execution\n      ideas.ts             # Ideas filesystem CRUD via SSH\n      claude.ts            # Claude Code CLI invocation and NDJSON parsing\n  dist/                    # Compiled output (tsc)\n  package.json\n  tsconfig.json\n</code></pre> <p>Key dependencies:</p> Package Purpose <code>express</code> HTTP server and routing <code>cookie-parser</code> Signed cookie parsing <code>cookie</code> Manual cookie parsing for WebSocket auth <code>ws</code> WebSocket server <code>ssh2</code> SSH connections to the dev-VM <code>uuid</code> Idea ID generation <code>slugify</code> Title-to-slug conversion <p>Scripts:</p> <ul> <li><code>dev</code> -- <code>bun --watch src/index.ts</code> (auto-restart on changes)</li> <li><code>build</code> -- <code>tsc</code> (compile to <code>dist/</code>)</li> <li><code>start</code> -- <code>bun dist/index.js</code></li> <li><code>typecheck</code> -- <code>tsc --noEmit</code></li> </ul>"},{"location":"development/project-structure/#catalystfrontend","title":"<code>@catalyst/frontend</code>","text":"<pre><code>packages/frontend/\n  src/\n    main.tsx               # React entry point, routing, AuthGuard\n    index.css              # Tailwind CSS entry point\n    pages/\n      Login.tsx            # Secret-based login form\n      Dashboard.tsx        # Ideas list with status badges\n      Capture.tsx          # New idea form\n      Session.tsx          # Chat/build interface with real-time streaming\n    components/\n      Layout.tsx           # App shell (sidebar + bottom nav)\n      ConnectionIndicator.tsx  # WebSocket status dot\n      Toast.tsx            # Toast notification system\n      ui/\n        badge.tsx          # shadcn/ui Badge component\n        button.tsx         # shadcn/ui Button component\n        input.tsx          # shadcn/ui Input component\n        textarea.tsx       # shadcn/ui Textarea component\n    hooks/\n      useWebSocket.ts      # WebSocket connection with auto-reconnect\n      useIdeas.ts          # Ideas REST API data fetching\n    stores/\n      auth.ts              # zustand auth state (check, login, logout)\n      connection.ts        # zustand WebSocket connection status\n    lib/\n      utils.ts             # Tailwind class merging utility (cn)\n  vite.config.ts           # Vite configuration with proxy and plugins\n  package.json\n  tsconfig.json\n</code></pre> <p>Key dependencies:</p> Package Purpose <code>react</code> + <code>react-dom</code> UI framework <code>react-router-dom</code> Client-side routing <code>zustand</code> State management <code>react-markdown</code> + <code>remark-gfm</code> Markdown rendering <code>react-syntax-highlighter</code> Code block syntax highlighting <code>lucide-react</code> Icons <code>class-variance-authority</code> Component variant system <code>tailwindcss</code> Utility-first CSS <p>Scripts:</p> <ul> <li><code>dev</code> -- <code>vite --port 3000</code> (dev server with HMR)</li> <li><code>build</code> -- <code>tsc --noEmit &amp;&amp; vite build</code> (type-check then bundle)</li> <li><code>typecheck</code> -- <code>tsc --noEmit</code></li> </ul>"},{"location":"development/project-structure/#helm-chart","title":"Helm Chart","text":"<pre><code>chart/\n  Chart.yaml               # Chart metadata (name, version, appVersion)\n  values.yaml              # Default configurable values\n  templates/\n    _helpers.tpl           # Template helpers for names and labels\n    configmap.yaml         # SSH_HOST, SSH_PORT, SSH_USER, IDEAS_BASE_PATH\n    deployment.yaml        # Pod spec with env vars, volume mounts, probes\n    ingress.yaml           # Nginx ingress with WebSocket annotations\n    namespace.yaml         # Namespace creation\n    networkpolicy.yaml     # Traffic restrictions\n    NOTES.txt              # Post-install user instructions\n    secret.yaml            # Optional chart-managed secrets\n    service.yaml           # ClusterIP service\n</code></pre> <p>See the Helm Values Reference for documentation of all configurable values.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This section walks you through everything needed to get Catalyst running, from prerequisites to a working local development environment.</p>"},{"location":"getting-started/#overview","title":"Overview","text":"<p>Catalyst has two runtime contexts that need to be set up:</p> <ol> <li>The Catalyst application itself -- a Node.js/Bun full-stack app (frontend + backend) that you run locally or deploy to Kubernetes.</li> <li>The dev-VM -- a separate machine (typically a Vagrant VM) where Claude Code is installed and where projects actually get built.</li> </ol> <p>The Catalyst app communicates with the dev-VM over SSH. When you chat with Claude or trigger a build, the backend SSHs into the dev-VM and runs <code>claude</code> as a subprocess, streaming its output back to your browser.</p>"},{"location":"getting-started/#steps","title":"Steps","text":"<ol> <li>Prerequisites -- Install the required tools and prepare your dev-VM.</li> <li>Installation -- Clone the repo, install dependencies, and run the app locally.</li> <li>Configuration -- Understand all the environment variables and how to customize Catalyst for your setup.</li> </ol>"},{"location":"getting-started/#minimum-viable-setup","title":"Minimum Viable Setup","text":"<p>For the fastest path to a working system:</p> <ol> <li>Install Bun on your local machine.</li> <li>Have an SSH-accessible machine with Claude Code installed.</li> <li>Clone the repo, run <code>bun install</code>, set <code>SSH_HOST</code> and <code>SSH_USER</code>, and run <code>bun run dev</code>.</li> <li>Open <code>http://localhost:3000</code> and enter the default secret (<code>dev-secret</code>).</li> </ol> <p>That is it. The more detailed guides below cover production deployment, Kubernetes, and advanced configuration.</p>"},{"location":"getting-started/configuration/","title":"Configuration","text":"<p>Catalyst is configured entirely through environment variables. There are no configuration files to edit. All variables have sensible defaults for local development, but several must be changed for production.</p>"},{"location":"getting-started/configuration/#environment-variables","title":"Environment Variables","text":""},{"location":"getting-started/configuration/#application-secrets","title":"Application Secrets","text":"Variable Description Default Required in Production <code>CATALYST_SECRET</code> The shared secret used to authenticate users. Users enter this value on the login screen. Must be a strong, unique string in production. <code>dev-secret</code> Yes <code>COOKIE_SECRET</code> Secret used to sign session cookies. Must be a strong, unique string in production. Used by <code>cookie-parser</code> for HMAC signing. <code>dev-cookie-secret</code> Yes <p>Warning</p> <p>The default secrets are suitable only for local development. In production, generate strong random values: <pre><code>openssl rand -hex 32\n</code></pre></p>"},{"location":"getting-started/configuration/#ssh-connection","title":"SSH Connection","text":"Variable Description Default <code>SSH_HOST</code> Hostname or IP address of the dev-VM where Claude Code runs. <code>localhost</code> <code>SSH_PORT</code> SSH port on the dev-VM. <code>22</code> <code>SSH_USER</code> Username for SSH authentication on the dev-VM. Value of <code>$USER</code> env var, or <code>user</code> <code>SSH_KEY_PATH</code> Path to the SSH private key file used for authentication. The backend reads this file at startup. <code>/secrets/ssh/id_ed25519</code> <code>SSH_KEY</code> Alternative to <code>SSH_KEY_PATH</code>. The SSH private key as a string. Useful when you cannot mount a key file (e.g., in some CI environments). Only used if <code>SSH_KEY_PATH</code> does not exist on disk. (empty) <code>MAX_SSH_CONNECTIONS</code> Maximum number of concurrent SSH connections in the pool. Each active Claude session or filesystem operation requires one connection. <code>3</code>"},{"location":"getting-started/configuration/#application-settings","title":"Application Settings","text":"Variable Description Default <code>PORT</code> Port the backend HTTP server listens on. <code>3001</code> <code>NODE_ENV</code> Set to <code>production</code> to serve frontend static files from the backend and enable secure cookie flags. <code>development</code> <code>IDEAS_BASE_PATH</code> Base directory on the dev-VM where idea folders are created. Each idea gets a subdirectory named by its slug (e.g., <code>~/catalyst/ideas/my-cool-idea/</code>). <code>~/catalyst/ideas</code> <code>CLAUDE_TIMEOUT_MS</code> Timeout in milliseconds for Claude Code processes. If Claude produces no output for this duration, the process is killed. <code>600000</code> (10 minutes)"},{"location":"getting-started/configuration/#how-configuration-is-loaded","title":"How Configuration is Loaded","text":"<p>The backend loads configuration in <code>packages/backend/src/config.ts</code> at startup. The <code>env()</code> helper reads from <code>process.env</code> with an optional fallback. If a required variable is missing and has no default, the server will crash immediately with a clear error message.</p> <pre><code>function env(key: string, fallback?: string): string {\n  const val = process.env[key] ?? fallback;\n  if (val === undefined) throw new Error(`Missing env var: ${key}`);\n  return val;\n}\n</code></pre> <p>SSH key loading follows a two-step process:</p> <ol> <li>Try to read the file at <code>SSH_KEY_PATH</code>.</li> <li>If the file does not exist, fall back to the <code>SSH_KEY</code> environment variable.</li> </ol> <p>This allows the same code to work both locally (where you have a key file) and in Kubernetes (where the key is mounted from a Secret).</p>"},{"location":"getting-started/configuration/#directory-structure-on-the-dev-vm","title":"Directory Structure on the Dev-VM","text":"<p>Catalyst creates the following structure under <code>IDEAS_BASE_PATH</code> on the dev-VM:</p> <pre><code>~/catalyst/ideas/\n  my-cool-idea/\n    meta.json          # Idea metadata (id, slug, title, status, sessionId, timestamps)\n    idea.md            # The original idea content entered during capture\n    project/           # Created when build mode is activated; Claude builds here\n      ...\n  another-idea/\n    meta.json\n    idea.md\n    project/\n      ...\n</code></pre> <p>The <code>meta.json</code> file tracks the idea lifecycle:</p> <pre><code>{\n  \"id\": \"a1b2c3d4-e5f6-7890-abcd-ef1234567890\",\n  \"slug\": \"my-cool-idea\",\n  \"title\": \"My Cool Idea\",\n  \"status\": \"chatting\",\n  \"sessionId\": \"sess_abc123\",\n  \"createdAt\": \"2025-01-15T10:30:00.000Z\",\n  \"updatedAt\": \"2025-01-15T11:45:00.000Z\"\n}\n</code></pre>"},{"location":"getting-started/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"getting-started/configuration/#local-development-minimal","title":"Local Development (Minimal)","text":"<pre><code>export SSH_HOST=192.168.56.10\nexport SSH_USER=vagrant\nexport SSH_KEY_PATH=~/.ssh/id_ed25519\n</code></pre> <p>Everything else uses defaults.</p>"},{"location":"getting-started/configuration/#docker-compose","title":"Docker Compose","text":"<p>See the <code>docker-compose.yml</code> in the project root. Environment variables are set in the <code>environment</code> block, and the SSH key is mounted as a read-only volume:</p> <pre><code>services:\n  catalyst:\n    build: .\n    ports:\n      - \"3001:3001\"\n    environment:\n      - CATALYST_SECRET=${CATALYST_SECRET:-dev-secret}\n      - COOKIE_SECRET=${COOKIE_SECRET:-dev-cookie-secret}\n      - SSH_HOST=${SSH_HOST:-host.docker.internal}\n      - SSH_PORT=${SSH_PORT:-22}\n      - SSH_USER=${SSH_USER:-user}\n      - SSH_KEY_PATH=/secrets/ssh/id_ed25519\n      - IDEAS_BASE_PATH=${IDEAS_BASE_PATH:-~/catalyst/ideas}\n    volumes:\n      - ${SSH_KEY_FILE:-~/.ssh/id_ed25519}:/secrets/ssh/id_ed25519:ro\n</code></pre>"},{"location":"getting-started/configuration/#kubernetes-via-helm","title":"Kubernetes (via Helm)","text":"<p>In Kubernetes, secrets are managed as <code>Secret</code> resources and non-sensitive config as a <code>ConfigMap</code>. See the Helm Values Reference for the full set of configurable values.</p>"},{"location":"getting-started/installation/","title":"Installation","text":"<p>This guide covers cloning the Catalyst repository, installing dependencies, and running the application locally for development.</p>"},{"location":"getting-started/installation/#clone-the-repository","title":"Clone the Repository","text":"<pre><code>git clone &lt;repo-url&gt; catalyst\ncd catalyst\n</code></pre>"},{"location":"getting-started/installation/#install-dependencies","title":"Install Dependencies","text":"<p>Catalyst is a monorepo with three packages (<code>shared</code>, <code>backend</code>, <code>frontend</code>). Bun's workspaces handle all of them in a single install:</p> <pre><code>bun install\n</code></pre> <p>This installs dependencies for all three packages and links the shared <code>@catalyst/shared</code> package so the backend and frontend can import types from it.</p>"},{"location":"getting-started/installation/#configure-environment","title":"Configure Environment","text":"<p>For local development, the defaults are designed to work out of the box with minimal configuration. The two things you most likely need to set are the SSH connection details for your dev-VM.</p> <p>Create a <code>.env</code> file in the project root (or export the variables in your shell):</p> <pre><code># .env (not committed to git)\nSSH_HOST=192.168.56.10       # Your dev-VM's IP or hostname\nSSH_USER=vagrant             # SSH username on the dev-VM\nSSH_KEY_PATH=~/.ssh/id_ed25519  # Path to your SSH private key\nIDEAS_BASE_PATH=~/catalyst/ideas  # Where ideas are stored on the dev-VM\n</code></pre> <p>Note</p> <p>For local development, <code>CATALYST_SECRET</code> defaults to <code>dev-secret</code> and <code>COOKIE_SECRET</code> defaults to <code>dev-cookie-secret</code>. These must be changed for production. See the Configuration page for all available variables.</p>"},{"location":"getting-started/installation/#run-locally","title":"Run Locally","text":"<p>Start both the backend and frontend in development mode:</p> <pre><code>bun run dev\n</code></pre> <p>This runs <code>bun run --filter '*' dev</code>, which starts:</p> <ul> <li>Backend on port <code>3001</code> -- Express server with hot reload via <code>bun --watch</code></li> <li>Frontend on port <code>3000</code> -- Vite dev server with HMR</li> </ul> <p>The Vite dev server proxies <code>/api/*</code> and <code>/ws</code> requests to the backend on port <code>3001</code>, so you only need to open one URL:</p> <pre><code>http://localhost:3000\n</code></pre>"},{"location":"getting-started/installation/#first-login","title":"First Login","text":"<ol> <li>Open <code>http://localhost:3000</code> in your browser.</li> <li>You will see a login screen asking for a secret.</li> <li>Enter <code>dev-secret</code> (the default <code>CATALYST_SECRET</code> for development).</li> <li>You are now on the Dashboard. Click the + button to capture your first idea.</li> </ol>"},{"location":"getting-started/installation/#verify-ssh-connectivity","title":"Verify SSH Connectivity","text":"<p>After logging in, you can check that the backend can reach your dev-VM by hitting the health endpoint:</p> <pre><code>curl http://localhost:3001/api/health\n</code></pre> <p>A healthy response looks like:</p> <pre><code>{\n  \"status\": \"ok\",\n  \"ssh\": true,\n  \"uptime\": 42.5\n}\n</code></pre> <p>If <code>ssh</code> is <code>false</code>, the backend cannot connect to the dev-VM. Double-check your <code>SSH_HOST</code>, <code>SSH_USER</code>, and <code>SSH_KEY_PATH</code> settings, and verify that you can SSH into the dev-VM manually:</p> <pre><code>ssh -i ~/.ssh/id_ed25519 vagrant@192.168.56.10 \"echo ok\"\n</code></pre>"},{"location":"getting-started/installation/#build-for-production","title":"Build for Production","text":"<p>To create a production build of both packages:</p> <pre><code>bun run build\n</code></pre> <p>This runs:</p> <ul> <li><code>tsc</code> for the backend (compiles TypeScript to <code>packages/backend/dist/</code>)</li> <li><code>tsc --noEmit &amp;&amp; vite build</code> for the frontend (type-checks then bundles to <code>packages/frontend/dist/</code>)</li> </ul> <p>To start the production server:</p> <pre><code>cd packages/backend\nbun dist/index.js\n</code></pre> <p>In production mode (<code>NODE_ENV=production</code>), the backend serves the frontend's static files from <code>packages/frontend/dist/</code> and handles the SPA fallback routing.</p>"},{"location":"getting-started/prerequisites/","title":"Prerequisites","text":"<p>Before setting up Catalyst, make sure you have the following tools and infrastructure in place.</p>"},{"location":"getting-started/prerequisites/#required","title":"Required","text":""},{"location":"getting-started/prerequisites/#bun","title":"Bun","text":"<p>Catalyst uses Bun as its package manager and runtime. Install it with:</p> <pre><code>curl -fsSL https://bun.sh/install | bash\n</code></pre> <p>Verify the installation:</p> <pre><code>bun --version\n</code></pre> <p>Catalyst is tested with Bun 1.x.</p>"},{"location":"getting-started/prerequisites/#nodejs","title":"Node.js","text":"<p>While Bun is the primary runtime, some tooling may reference Node.js APIs. Bun provides Node.js compatibility out of the box, so a separate Node.js installation is not strictly required. However, if you encounter issues, having Node.js 22+ available is recommended.</p>"},{"location":"getting-started/prerequisites/#ssh-accessible-dev-vm","title":"SSH-Accessible Dev-VM","text":"<p>Catalyst requires a machine it can SSH into where Claude Code will run. This is typically a Vagrant VM, but any SSH-accessible Linux machine works. Requirements for the dev-VM:</p> <ul> <li>SSH server running and accessible from the Catalyst host</li> <li> <p>Claude Code CLI installed and authenticated. Install it with:</p> <pre><code>npm install -g @anthropic-ai/claude-code\n</code></pre> <p>Then run <code>claude</code> once interactively to complete authentication.</p> </li> <li> <p>SSH key-based authentication configured. Catalyst connects using an SSH private key, not a password. Generate a key pair if you do not have one:</p> <pre><code>ssh-keygen -t ed25519 -C \"catalyst\" -f ~/.ssh/catalyst_ed25519\nssh-copy-id -i ~/.ssh/catalyst_ed25519.pub user@dev-vm\n</code></pre> </li> <li> <p>Development tools installed on the VM (git, your preferred language runtimes, etc.). Claude Code will use whatever tools are available on the VM when building projects.</p> </li> </ul>"},{"location":"getting-started/prerequisites/#git","title":"Git","text":"<p>Required for cloning the repository and for Claude Code to work with version control during builds.</p> <pre><code>git --version\n</code></pre>"},{"location":"getting-started/prerequisites/#required-for-production-deployment","title":"Required for Production Deployment","text":""},{"location":"getting-started/prerequisites/#docker","title":"Docker","text":"<p>Needed for building the container image.</p> <pre><code>docker --version\n</code></pre>"},{"location":"getting-started/prerequisites/#kubernetes-cluster","title":"Kubernetes Cluster","text":"<p>Catalyst is designed to run on a local Kubernetes cluster (e.g., k3s, microk8s, or kind) behind a VPN. You need:</p> <ul> <li>A running Kubernetes cluster with <code>kubectl</code> configured</li> <li>An nginx ingress controller installed in the cluster</li> <li> <p>Helm 3 for deploying the chart:</p> <pre><code>helm version\n</code></pre> </li> </ul>"},{"location":"getting-started/prerequisites/#vpn","title":"VPN","text":"<p>Since Catalyst provides direct access to Claude Code with full tool permissions in build mode, it should only be accessible over a VPN. The specific VPN solution is up to you (WireGuard, Tailscale, etc.), but the ingress should not be publicly exposed.</p>"},{"location":"getting-started/prerequisites/#optional","title":"Optional","text":""},{"location":"getting-started/prerequisites/#docker-compose","title":"Docker Compose","text":"<p>Useful for a quick single-machine deployment without Kubernetes:</p> <pre><code>docker compose version\n</code></pre>"},{"location":"getting-started/prerequisites/#vagrant","title":"Vagrant","text":"<p>If you use Vagrant to manage your dev-VM:</p> <pre><code>vagrant --version\n</code></pre> <p>A typical Vagrantfile might expose SSH on a known port and install Claude Code in the provisioning step.</p>"},{"location":"getting-started/prerequisites/#summary-checklist","title":"Summary Checklist","text":"Prerequisite Required For How to Check Bun 1.x All <code>bun --version</code> SSH key pair All <code>ls ~/.ssh/id_ed25519</code> Dev-VM with Claude Code All <code>ssh user@dev-vm \"claude --version\"</code> Docker Container builds <code>docker --version</code> Kubernetes + kubectl Production deployment <code>kubectl cluster-info</code> Helm 3 Helm chart deployment <code>helm version</code> Nginx ingress controller K8s ingress <code>kubectl get pods -n ingress-nginx</code> VPN Production security Depends on your VPN solution"}]}